{
    "version": "https://jsonfeed.org/version/1",
    "title": "个人博客",
    "subtitle": "",
    "icon": "https://seele-exzzz.github.io/assets/favicon.ico",
    "description": "",
    "home_page_url": "https://seele-exzzz.github.io",
    "items": [
        {
            "id": "https://seele-exzzz.github.io/2023/09/11/project/ProjectFunction/",
            "url": "https://seele-exzzz.github.io/2023/09/11/project/ProjectFunction/",
            "title": "项目功能介绍",
            "date_published": "2023-09-11T07:06:23.365Z",
            "content_html": "<h2 id=\"截图\"><a class=\"markdownIt-Anchor\" href=\"#截图\">#</a> 截图</h2>\n<h3 id=\"1-画笔橡皮擦文字复制到剪切板的功能展示\"><a class=\"markdownIt-Anchor\" href=\"#1-画笔橡皮擦文字复制到剪切板的功能展示\">#</a> 1. 画笔，橡皮擦，文字，复制到剪切板的功能展示。</h3>\n<p>​\t画笔：可以使用下面的按钮以及输入框改变画笔的大小并在截图区域绘制。</p>\n<p>​    橡皮擦：清除用画笔绘制的内容同时可以使用下面的按钮以及输入框改变橡皮擦的大小</p>\n<p>​\t文字：在截图框输入文字。</p>\n<p>​\t复制：点击√即可复制到剪切板。</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/qiuzhao/projectezgif.com-video-to-gif.gif\" alt=\"\"></p>\n<h3 id=\"2-退出撤回保存的功能展示\"><a class=\"markdownIt-Anchor\" href=\"#2-退出撤回保存的功能展示\">#</a> 2. 退出，撤回，保存的功能展示。</h3>\n<p>​\t\t退出：右键可以退出截图同时截图框可以拖动，截图内容以拖动后的截图框为主。</p>\n<p>​\t\t撤回：当进入编辑截图时，点击撤回即可清除绘制以及文本等等内容。</p>\n<p>​\t\t保存：保存按钮将图片保存。</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/qiuzhao/projectezgif.com-video-to-gif%20(1).gif\" alt=\"\"></p>\n<h2 id=\"便利贴\"><a class=\"markdownIt-Anchor\" href=\"#便利贴\">#</a> 便利贴</h2>\n<h3 id=\"1创建清除便利贴的功能展示\"><a class=\"markdownIt-Anchor\" href=\"#1创建清除便利贴的功能展示\">#</a> 1. 创建，清除便利贴的功能展示。</h3>\n<p>​\t 可以创建便利贴并在便利贴记录事情。便利贴可以创建多个，且可以移动。当事情完成后就可以清除。当软件启动时，未清除的便利贴还会显示。</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/qiuzhao/projectezgif.com-video-to-gif%20(2).gif\" alt=\"\"></p>\n<h3 id=\"软件地址\"><a class=\"markdownIt-Anchor\" href=\"#软件地址\">#</a> 软件地址：</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMU1va1oxc1c4LXJENlRrdHhyancwQkE/cHdkPTEyMzQ=\">百度网盘</span></p>\n<p><a href=\"[Release 修复了图标,便利贴清除等相关bug · SEELE-EXZzz/desktool (github.com)](https://github.com/SEELE-EXZzz/desktool/releases/tag/1.1.0)\">GitHub</a></p>\n",
            "tags": []
        },
        {
            "id": "https://seele-exzzz.github.io/2023/08/12/project/%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE%E5%8A%9F%E8%83%BD/",
            "url": "https://seele-exzzz.github.io/2023/08/12/project/%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%9B%BE%E5%8A%9F%E8%83%BD/",
            "title": "electron截图功能",
            "date_published": "2023-08-12T10:29:32.591Z",
            "content_html": "<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>想要实现截图功能，需要设置一个全屏隐藏菜单栏且透明的窗口，在窗口上放上屏幕的截图，然后监听鼠标，获取两次鼠标点击的位置，根据这个位置将图片用 canvas.drawImage 方法将图片写入 canvas 标签。然后再做保存或者写入剪切板的操作。</p>\n<h2 id=\"一-基本功能\"><a class=\"markdownIt-Anchor\" href=\"#一-基本功能\">#</a> 一、基本功能</h2>\n<h3 id=\"一-进程间通信\"><a class=\"markdownIt-Anchor\" href=\"#一-进程间通信\">#</a> 一、进程间通信</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//渲染进程</span><br><span class=\"line\">&lt;el-button type=&quot;primary&quot; @click=&quot;screenHot&quot;&gt;截图&lt;/el-button&gt; //设置一个按钮。</span><br><span class=\"line\">screenHot()&#123;</span><br><span class=\"line\">    ipcRenderer.send(&#x27;screenHot&#x27;)</span><br><span class=\"line\">&#125;//向主进程发送消息。</span><br><span class=\"line\"></span><br><span class=\"line\">//主进程</span><br><span class=\"line\">let fullScreen</span><br><span class=\"line\">ipcMain.on(&#x27;screenHot&#x27;,async()=&gt;&#123;</span><br><span class=\"line\">\twin.hide()//主窗口隐藏</span><br><span class=\"line\">    //创建一个全屏且隐藏菜单栏的窗口。</span><br><span class=\"line\">    fullScreen= new BrowserWindow(&#123;</span><br><span class=\"line\">        autoHideMenuBar: true, // 自动隐藏菜单栏</span><br><span class=\"line\">        useContentSize: true, // width 和 height 将设置为 web 页面的尺寸</span><br><span class=\"line\">        movable: false, // 是否可移动</span><br><span class=\"line\">        frame: false, // 无边框窗口</span><br><span class=\"line\">        resizable: false, // 窗口大小是否可调整</span><br><span class=\"line\">        hasShadow: false, // 窗口是否有阴影</span><br><span class=\"line\">        transparent: true, // 使窗口透明</span><br><span class=\"line\">        fullscreenable: true, // 窗口是否可以进入全屏状态</span><br><span class=\"line\">        fullscreen: true, // 窗口是否全屏</span><br><span class=\"line\">        simpleFullscreen: true, // 在 macOS 上使用 pre-Lion 全屏</span><br><span class=\"line\">        alwaysOnTop: false, // 窗口是否永远在别的窗口的上面</span><br><span class=\"line\">      webPreferences: &#123;</span><br><span class=\"line\">        nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION,</span><br><span class=\"line\">        contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    if (process.env.WEBPACK_DEV_SERVER_URL) &#123;</span><br><span class=\"line\">      await fullScreen.loadURL(process.env.WEBPACK_DEV_SERVER_URL+&#x27;screenHot.html&#x27;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      createProtocol(&#x27;app&#x27;)</span><br><span class=\"line\">      fullScreen.loadURL(&#x27;app://./screenHot.html&#x27;)//加载页面</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">ipcMain.on(&#x27;getFullScreen&#x27;,async() =&gt; &#123;</span><br><span class=\"line\">  //获取屏幕大小,以及缩放因子scaleFactor。</span><br><span class=\"line\">  const &#123; size, scaleFactor &#125; = screen.getPrimaryDisplay()</span><br><span class=\"line\">  const sources = await desktopCapturer.getSources(&#123;</span><br><span class=\"line\">    types:[&#x27;screen&#x27;],</span><br><span class=\"line\">    thumbnailSize: &#123;</span><br><span class=\"line\">      width:size.width*scaleFactor,</span><br><span class=\"line\">      height:size.height*scaleFactor</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  // 向渲染进程发送屏幕截图</span><br><span class=\"line\">  fullScreen.webContents.send(&#x27;sendFullScreen&#x27;, sources[0],size)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-渲染进程获取桌面截图\"><a class=\"markdownIt-Anchor\" href=\"#二-渲染进程获取桌面截图\">#</a> 二、渲染进程获取桌面截图</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;img&gt;</span><br><span class=\"line\">  &lt;canvas&gt;&lt;/canvas&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">mounted()&#123;</span><br><span class=\"line\">        let img = document.querySelector(&#x27;img&#x27;) </span><br><span class=\"line\">        ipcRenderer.send(&#x27;getFullScreen&#x27;)</span><br><span class=\"line\">        ipcRenderer.on(&#x27;sendFullScreen&#x27;, (event, message) =&gt; &#123;</span><br><span class=\"line\">            img.src = message.thumbnail.toDataURL()   </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-监听鼠标获取坐标\"><a class=\"markdownIt-Anchor\" href=\"#三-监听鼠标获取坐标\">#</a> 三、监听鼠标获取坐标</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    //获取第一次鼠标按下时的坐标</span><br><span class=\"line\">    getStartPostion(e)&#123;</span><br><span class=\"line\">        this.startX = e.clientX</span><br><span class=\"line\">        this.startY = e.clientY</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //获取移动时的坐标</span><br><span class=\"line\">    getlastPostion(e)&#123;</span><br><span class=\"line\">        this.endX = e.clientX</span><br><span class=\"line\">        this.endY = e.clientY</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //删除mousemove的监听事件</span><br><span class=\"line\">    getfinallyPostion()&#123;</span><br><span class=\"line\">        document.removeEventListener(&#x27;mousemove&#x27;,this.getlastPostion)</span><br><span class=\"line\">    &#125;\t\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mounted()&#123;</span><br><span class=\"line\">    document.addEventListener(&#x27;mousedown&#x27;,this.getStartPostion)</span><br><span class=\"line\">    document.addEventListener(&#x27;mousemove&#x27;,this.getlastPostion)</span><br><span class=\"line\">    document.addEventListener(&#x27;mouseup&#x27;,this.getfinallyPostion)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"四-根据坐标生成一个矩形的截图区域\"><a class=\"markdownIt-Anchor\" href=\"#四-根据坐标生成一个矩形的截图区域\">#</a> 四、根据坐标生成一个矩形的截图区域</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-show=&quot;isShowCutScreen&quot; :style=&quot;&#123;</span><br><span class=\"line\">    position: &#x27;absolute&#x27;,</span><br><span class=\"line\">    left: startX + &#x27;px&#x27;,</span><br><span class=\"line\">    top: startY + &#x27;px&#x27;,</span><br><span class=\"line\">    width: (endX - startX) + &#x27;px&#x27;,</span><br><span class=\"line\">    height: (endY - startY) + &#x27;px&#x27;,</span><br><span class=\"line\">    border: &#x27;2px solid black&#x27;,</span><br><span class=\"line\">  &#125;&quot;&gt; </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data()&#123;</span><br><span class=\"line\">\treturn&#123;</span><br><span class=\"line\">        isShowCutScreen:false,</span><br><span class=\"line\">        startX:0, </span><br><span class=\"line\">        startY:0,</span><br><span class=\"line\">        endX:0,</span><br><span class=\"line\">        endY:0,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//鼠标第一个点击时，截图区域展示出来</span><br><span class=\"line\">getStartPostion(e)&#123;</span><br><span class=\"line\">    if(!this.isShowCutScreen)&#123;</span><br><span class=\"line\">      this.isShowCutScreen = true  </span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.startX = e.clientX</span><br><span class=\"line\">    this.startY = e.clientY</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//截图区域展示后再获取鼠标移动时的坐标</span><br><span class=\"line\">getlastPostion(e)&#123;</span><br><span class=\"line\">    if(!this.isShowCutScreen) return</span><br><span class=\"line\">    this.endX = e.clientX</span><br><span class=\"line\">    this.endY = e.clientY</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-将截图写入canvas同时复制至剪切板\"><a class=\"markdownIt-Anchor\" href=\"#五-将截图写入canvas同时复制至剪切板\">#</a> 五、将截图写入 canvas 同时复制至剪切板</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button v-show=&quot;isShowSetting&quot; @click=&quot;copyToclipboard&quot;&gt;复制并关闭&lt;/button&gt;</span><br><span class=\"line\">copyToclipboard()&#123;</span><br><span class=\"line\">\t/*获取物理像素与CSS像素之比，有些设备这个比值会大于一，如果不乘这个值就会出现，截图位置和大小有偏差。相当于将截图区域的图片放大这个系数放在没有放大的canvas中，截图范围变小。*/</span><br><span class=\"line\">    const devicePixelRatio = window.devicePixelRatio</span><br><span class=\"line\">    let canvas = document.querySelector(&#x27;canvas&#x27;)</span><br><span class=\"line\">    let ctx=canvas.getContext(&quot;2d&quot;)</span><br><span class=\"line\">    let img=document.querySelector(&#x27;img&#x27;)</span><br><span class=\"line\">    let startX = this.startX*devicePixelRatio</span><br><span class=\"line\">    let startY = this.startY*devicePixelRatio</span><br><span class=\"line\">    let endX = this.endX*devicePixelRatio</span><br><span class=\"line\">    let endY = this.endY*devicePixelRatio</span><br><span class=\"line\">    let width = endX-startX</span><br><span class=\"line\">    let height = endY-startY</span><br><span class=\"line\">    canvas.width = width</span><br><span class=\"line\">    canvas.height = height</span><br><span class=\"line\">    ctx.drawImage(img,startX,startY,width,height,0,0,width,height)</span><br><span class=\"line\">    //将canvas变成blob对象，然后使用clipboard复制到剪切板中</span><br><span class=\"line\">    canvas.toBlob((blob)=&gt;&#123;</span><br><span class=\"line\">        navigator.clipboard.write([new ClipboardItem(&#123; &#x27;image/png&#x27;: blob &#125;)]).then(()=&gt;&#123;</span><br><span class=\"line\">            ipcRenderer.send(&#x27;closeFullScreen&#x27;)</span><br><span class=\"line\">        &#125;).catch((err)=&gt;console.log(err))</span><br><span class=\"line\">    &#125;)          </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n<ol>\n<li><a href=\"[基于electron、vite 和 react，我做了一个截图桌面软件 - 掘金 (juejin.cn)](https://juejin.cn/post/7239514481755127845?searchId=202308102041027394C7E481B4D632E215)\">在 electron 中实现截图</a></li>\n<li><a href=\"[用Vite+Electron搞个微信截图工具（区域截屏工具） - 掘金 (juejin.cn)](https://juejin.cn/post/7111115472182968327?searchId=20230810204054CAEE239023ED2A291BEA)\">在 electron 中实现截图</a></li>\n<li><a href=\"[剪贴板操作 Clipboard API 教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2021/01/clipboard-api.html)\">剪切板使用</a></li>\n<li></li>\n</ol>\n",
            "tags": [
                "项目",
                "vue",
                "electron",
                "element-ui",
                "项目"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/08/09/algorithm/acm%E6%A8%A1%E5%BC%8F/",
            "url": "https://seele-exzzz.github.io/2023/08/09/algorithm/acm%E6%A8%A1%E5%BC%8F/",
            "title": "acm模式",
            "date_published": "2023-08-09T10:23:41.906Z",
            "content_html": "<h2 id=\"acm模式\"><a class=\"markdownIt-Anchor\" href=\"#acm模式\">#</a> acm 模式</h2>\n<p>众所周知，企业机试是要使用 acm 模式的即自行处理输入输出，而不是力扣上的那种核心代码模式。所以之后了解了一下 JavaScript 获取输入输出的方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">\tjavaScript Node模式</span><br><span class=\"line\">*/</span><br><span class=\"line\">const readline = require(&#x27;readline&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">const rl = readline.createInterface(&#123;</span><br><span class=\"line\">\tinput:process.stdin,</span><br><span class=\"line\">\toutput:process.stdout</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">rl.on(&#x27;line&#x27;,(input)=&gt;&#123;</span><br><span class=\"line\">\t//处理输入的每行数据，这里就是之前力扣上要写的代码。</span><br><span class=\"line\">\t//input就是输入数据。另外有时input并不是处理的数据而是条件所以在处理数据的时候还需要判断一下。</span><br><span class=\"line\">\tconsole.log()//在力扣return是输出数据，而acm模式则是通过console.log打印输出数据</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 与力扣相比就多了以上这些代码。</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理输入\"><a class=\"markdownIt-Anchor\" href=\"#处理输入\">#</a> 处理输入</h2>\n<h3 id=\"1-输入的类型转化\"><a class=\"markdownIt-Anchor\" href=\"#1-输入的类型转化\">#</a> 1. 输入的类型转化</h3>\n<p>在获取到数据后，需要分辨那些是需要用的，那些是用不着的。同时还需对数据作类型转化。因为拿到的数据大概率是字符串，需要将字符串转化为需要的数据类型比如数组，数字。可以使用正则判断，到底是数组字符串还是数字字符串。</p>\n<h4 id=\"1-字符串转数字\"><a class=\"markdownIt-Anchor\" href=\"#1-字符串转数字\">#</a> 1. 字符串转数字</h4>\n<p>​\t首先如果一行只有数字的话，可以匹配非数字以及空格，如果匹配成功就说明这一行除数字，换行等其他数据类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg = /[^0-9\\s]/g</span><br><span class=\"line\">//input为输入数据，如果成功匹配则说明有除了数字空格等其他数据类型</span><br><span class=\"line\">if(!reg.test(input))&#123;</span><br><span class=\"line\">\ttodo //如果只想要某行数据是只有数字的话</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2字符串转数组\"><a class=\"markdownIt-Anchor\" href=\"#2字符串转数组\">#</a> 2. 字符串转数组</h4>\n<p>因为数组有 [] 可以匹配这个，另外也可以使用字符串的 indexOf 方法获取 [] 的下标，用 slice () 截取字符串数组中数组的部分，然后使用 split (‘’) 转成数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = input.slice(input.indexOf(&#x27;[&#x27;),input.indexOf(&#x27;]&#x27;)+1).spilt(&#x27;&#x27;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2输入的数据构造二叉树或者链表\"><a class=\"markdownIt-Anchor\" href=\"#2输入的数据构造二叉树或者链表\">#</a> 2. 输入的数据构造二叉树或者链表</h3>\n",
            "tags": [
                "算法",
                "算法"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/08/03/project/electron-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAelectron%E9%A1%B9%E7%9B%AE/",
            "url": "https://seele-exzzz.github.io/2023/08/03/project/electron-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAelectron%E9%A1%B9%E7%9B%AE/",
            "title": "electron配置",
            "date_published": "2023-08-03T07:04:45.388Z",
            "content_html": "<h1 id=\"electron-从零搭建一个electron项目\"><a class=\"markdownIt-Anchor\" href=\"#electron-从零搭建一个electron项目\">#</a> electron - 从零搭建一个 electron 项目</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>要想将 vue 引入 electron 中有两种方式，分别为 electron-vue 和 Vue CLI Plugin Electron Builder. 前者虽然出的早，但很久不维护了。因此这边使用后者即 Vue CLI Plugin Electron Builder。首先需要用 vue 的脚手架生成 vue 项目，然后在引入 electron 插件。</p>\n<h2 id=\"创建electron项目\"><a class=\"markdownIt-Anchor\" href=\"#创建electron项目\">#</a> 创建 electron 项目</h2>\n<h3 id=\"1-创建vue项目\"><a class=\"markdownIt-Anchor\" href=\"#1-创建vue项目\">#</a> 1、创建 vue 项目</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i @vue/cli -g //全局安装vue cli脚手架</span><br><span class=\"line\">vue create &lt;name&gt; //脚手架创建vue项目，前面和创建vue项目一模一样</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-添加electron插件\"><a class=\"markdownIt-Anchor\" href=\"#2-添加electron插件\">#</a> 2、添加 electron 插件</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue add electron-builder </span><br><span class=\"line\">cnpm i electron --S //这里用npm的话大概率下载不了，因为electron有一部分代码在GitHub中，要么改镜像要么直接用cnpm</span><br></pre></td></tr></table></figure>\n<p>这时一个 electron 项目就出来了。</p>\n<h2 id=\"配置\"><a class=\"markdownIt-Anchor\" href=\"#配置\">#</a> 配置</h2>\n<p>如果用最新的 vue-cli 的话，这时 webpack 应该在 5 以上，5 以上的 webpack 不再自动引入 polyfill 了，原因是引入这个会让最后的打包体积变得很大，webpack 不建议开发者在浏览器端使用 polyfill。现在要么不用 node，要么手动引入 polyfill。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm install --save path-browserify crypto-browserify//安装path-browserify和crypto-browserify</span><br><span class=\"line\"></span><br><span class=\"line\">//在vue.config.js中加入如下配置。</span><br><span class=\"line\">module.exports = defineConfig(&#123;</span><br><span class=\"line\">  transpileDependencies: true,</span><br><span class=\"line\">  configureWebpack: &#123;</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">      fallback: &#123;</span><br><span class=\"line\">        &quot;fs&quot;: false,</span><br><span class=\"line\">        &quot;path&quot;: require.resolve(&quot;path-browserify&quot;),</span><br><span class=\"line\">        &quot;crypto&quot;: require.resolve(&quot;crypto-browserify&quot;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>之后会出现’__dirname is not defined’这个错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在上面的基础上加如下的配置即可。</span><br><span class=\"line\">pluginOptions:&#123;</span><br><span class=\"line\">   electronBuilder:&#123;</span><br><span class=\"line\">     nodeIntegration:true</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "项目",
                "vue",
                "electron",
                "element-ui",
                "项目"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/08/02/algorithm/%E9%93%BE%E8%A1%A8%E8%BF%9B%E9%98%B6-%E8%AE%BA%E9%80%92%E5%BD%92%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/",
            "url": "https://seele-exzzz.github.io/2023/08/02/algorithm/%E9%93%BE%E8%A1%A8%E8%BF%9B%E9%98%B6-%E8%AE%BA%E9%80%92%E5%BD%92%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/",
            "title": "链表进阶",
            "date_published": "2023-08-02T13:31:36.133Z",
            "content_html": "<h1 id=\"链表进阶-论递归在链表中的作用\"><a class=\"markdownIt-Anchor\" href=\"#链表进阶-论递归在链表中的作用\">#</a> 链表进阶 - 论递归在链表中的作用</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>初次接触链表的时候，一方面在改变指针的时候容易出现问题导致链表出现环，当然之后只要涉及改变指针就靠画图理顺指针改变顺序解决了这个问题，另一方面链表与数组不一样的点在于链表无法回退，这时递归登场了，因为递归有回溯的过程，所以只要将链表的下一项当作参数，那么在回溯的时候自然就会进行回退。使用递归能很轻松地解决蛮多链表的问题。以下是一些用递归解决链表的类型题目。</p>\n<h2 id=\"一-反转链表\"><a class=\"markdownIt-Anchor\" href=\"#一-反转链表\">#</a> 一 、反转链表</h2>\n<p>这类型题目主要是需要在外面设置一个变量储存链表，然后将链表的下一项当作递归的参数，当到达要交换的最后一个节点时就要 return，然后在回溯的部分交换，外面的链表记得在交换后往前走，里面的链表在返回上一层函数的时候会自动回退，这就起到了前后两边交换节点。同时反转链表有两种情况，一种是反转相邻的节点，另一种是反转的节点隔一个节点。</p>\n<h3 id=\"a-href剑指-offer-ii-024-反转链表-力扣leetcodehttpsleetcodecnproblemsuhnkqh剑指-offer-ii-024-反转链表a\"><a class=\"markdownIt-Anchor\" href=\"#a-href剑指-offer-ii-024-反转链表-力扣leetcodehttpsleetcodecnproblemsuhnkqh剑指-offer-ii-024-反转链表a\">#</a> <a href=\"[剑指 Offer II 024. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/UHnkqh/)\">剑指 Offer II 024. 反转链表</a></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverseList = function(head) &#123;</span><br><span class=\"line\">    if(!head||!head.next) return head //如果链表为空或者只有一项return原链表就行</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    \t这里用到了虚拟头节点，因为第一个头节点也要交换如果设置虚拟头节点方便交换头节点，另外也需要在外面设置一个变量一个正向移动，另一个在回溯中逆向移动两个交换节点就能实现链表反转。</span><br><span class=\"line\">    */</span><br><span class=\"line\">    let cur = new ListNode(0,head),node = cur</span><br><span class=\"line\">    const dfs=(list)=&gt;&#123;</span><br><span class=\"line\">    \t//因为最后一个节点要交换，交换节点需要到前一个节点，所以这里到最后一个节点就return这样回溯部分就从倒二个节点开始回退</span><br><span class=\"line\">        if(!list.next) return</span><br><span class=\"line\">        //一旦交换成功就return true，一旦return的结果是true就立马return true防止继续进行回溯部分。导致已经交换过的节点继续交换。</span><br><span class=\"line\">        if(dfs(list.next)) return true </span><br><span class=\"line\">        //最后一次交换有两种情况，一种就是这个，交换节点挨着。</span><br><span class=\"line\">        if(cur.next==list)&#123;</span><br><span class=\"line\">            let temp = cur.next</span><br><span class=\"line\">            cur.next = cur.next.next</span><br><span class=\"line\">            temp.next = cur.next.next</span><br><span class=\"line\">            cur.next.next = temp</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //大部分交换时，交换的节点都隔着节点</span><br><span class=\"line\">        let temp1 = cur.next,temp2=list.next</span><br><span class=\"line\">        cur.next = cur.next.next</span><br><span class=\"line\">        list.next = list.next.next</span><br><span class=\"line\">        temp2.next = cur.next</span><br><span class=\"line\">        cur.next = temp2</span><br><span class=\"line\">        temp1.next = list.next</span><br><span class=\"line\">        list.next = temp1</span><br><span class=\"line\">        cur = temp2</span><br><span class=\"line\">        //如果要交换的节点之间隔着一个节点，交换后cur的下个节点就是list这时该赶紧return。</span><br><span class=\"line\">        if(cur.next==list) return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(node)</span><br><span class=\"line\">    return node.next //最后return记得不要带上自己设置的虚拟头节点。</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"a-href92-反转链表-ii-力扣leetcodehttpsleetcodecnproblemsreverse-linked-list-ii-92-反转链表-iia\"><a class=\"markdownIt-Anchor\" href=\"#a-href92-反转链表-ii-力扣leetcodehttpsleetcodecnproblemsreverse-linked-list-ii-92-反转链表-iia\">#</a> <a href=\"[92. 反转链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list-ii/)\"> 92. 反转链表 II</a></h3>\n<p>这题与上面一题差别在于，不是整个链表反转。因此在在用递归反转链表时，需用 while 循环到达需要反转的链表节点前面，同时递归函数增加一个参数用于判断是否到达了最后一个需要反转的节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverseBetween = function(head, left, right) &#123;</span><br><span class=\"line\">    if(!head.next||left==right) return head </span><br><span class=\"line\">    let node = new ListNode(0,head) //这里同样需要设置虚拟头节点，因为有可能left为1，头节点需要反转。</span><br><span class=\"line\">    let l=node,r=node</span><br><span class=\"line\">    //用while循环让l和r达到需要交换的第一个节点前。</span><br><span class=\"line\">    while(left&gt;1)&#123;</span><br><span class=\"line\">       l=l.next</span><br><span class=\"line\">       r=r.next</span><br><span class=\"line\">       left --</span><br><span class=\"line\">       right --</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //下面代码与上题一致，无非就是多了参数，判断条件有变，交换部分的代码一致。</span><br><span class=\"line\">    const dfs =(r,right)=&gt;&#123;</span><br><span class=\"line\">        if(right==0) return</span><br><span class=\"line\">        if(dfs(r.next,right-1)) return true</span><br><span class=\"line\">        if(l.next==r)&#123;</span><br><span class=\"line\">            l.next = l.next.next</span><br><span class=\"line\">            r.next = l.next.next</span><br><span class=\"line\">            l.next.next = r</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let temp1=l.next,temp2=r.next</span><br><span class=\"line\">        l.next = l.next.next</span><br><span class=\"line\">        r.next = r.next.next</span><br><span class=\"line\">        temp1.next = r.next</span><br><span class=\"line\">        r.next = temp1</span><br><span class=\"line\">        temp2.next = l.next</span><br><span class=\"line\">        l.next = temp2 </span><br><span class=\"line\">        l = temp2</span><br><span class=\"line\">        if(l==r||l.next==r) return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(r,right)</span><br><span class=\"line\">    return node.next</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"a-href2074-反转偶数长度组的节点-力扣leetcodehttpsleetcodecnproblemsreverse-nodes-in-even-length-groups2074-反转偶数长度组的节点a\"><a class=\"markdownIt-Anchor\" href=\"#a-href2074-反转偶数长度组的节点-力扣leetcodehttpsleetcodecnproblemsreverse-nodes-in-even-length-groups2074-反转偶数长度组的节点a\">#</a> <a href=\"[2074. 反转偶数长度组的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/)\">2074. 反转偶数长度组的节点</a></h3>\n<p>这题相比于上一题在于不只反转一次。反转的代码依旧可以用上面代码不过判断条件复杂一些。另外最后一组的链表长度如果小于倒数第二组的长度，这时如果长度为偶数则还要反转，而不是最后一组是偶数组才要反转，一开始还理解错误题目来着。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverseEvenLengthGroups = function(head) &#123;</span><br><span class=\"line\">    if(!head||!head.next||!head.next.next) return head</span><br><span class=\"line\">    let cur = head,outside = head,inside = head,index = 2</span><br><span class=\"line\">    const dfs =(list,num,k)=&gt;&#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    \t判断条件相比之前的题有亿点多，一共有四种情况。分为两大类一类是没走完，另一类是走到末尾了。反转链表的代码还是一样。</span><br><span class=\"line\">    \t没走完的情况：</span><br><span class=\"line\">    \t1.这时list不为空，num为0。如果当前所在组是奇数，k%2为1 这时不该反转链表，也是不执行回溯部分代码，需return一个值，这里我return-1，下面接收值，如果是-1就立即return-1</span><br><span class=\"line\">    \t2.如果当前所在组是偶数，k%2为0 这时该反转链表，这里return不return值都行。反正要执行下面回溯部分的反转链表的代码。</span><br><span class=\"line\">    \t走完的情况：</span><br><span class=\"line\">    \t3.如果剩余链表数为偶数的话，k-num%2为0，这时要执行回溯部分的代码反转链表，记得这时需到最后一个链表后再return，因为最后一个要反转，所以反转时需到倒数第二个链表的位置。所以这里的判断条件是!list.next而且这个条件需在!list之下不然会出现list为空所以没有list.next的错误。</span><br><span class=\"line\">    \t4. 如果剩余链表数为奇数的话，这时list为空，同样return一个值，下面用一个变量接住后，加个判断条件return出去，防止执行回溯部分的代码。</span><br><span class=\"line\">    */</span><br><span class=\"line\">        if(!list) return false</span><br><span class=\"line\">        if(!list.next&amp;&amp;(k-num)%2==0) return</span><br><span class=\"line\">        if(num==0&amp;&amp;k%2==0) return</span><br><span class=\"line\">        if(num==0) return -1</span><br><span class=\"line\">        let res = dfs(list.next,num-1,k)</span><br><span class=\"line\">        if(res==true)&#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;else if(res ==false)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;else if(res==-1)&#123;</span><br><span class=\"line\">            return -1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(outside.next==list)&#123;</span><br><span class=\"line\">            let temp = list</span><br><span class=\"line\">            outside.next = outside.next.next</span><br><span class=\"line\">            temp.next = outside.next.next</span><br><span class=\"line\">            outside.next.next = temp</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let temp2 = list.next,temp1 = outside.next</span><br><span class=\"line\">        list.next = list.next.next</span><br><span class=\"line\">        outside.next = outside.next.next</span><br><span class=\"line\">        temp2.next = outside.next</span><br><span class=\"line\">        outside.next = temp2</span><br><span class=\"line\">        temp1.next = list.next</span><br><span class=\"line\">        list.next = temp1</span><br><span class=\"line\">        outside = temp2</span><br><span class=\"line\">        if(outside.next == list) return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(cur)&#123;</span><br><span class=\"line\">        if(dfs(inside,index,index)===false) return cur </span><br><span class=\"line\">        //注意递归运行完后这里的outside会发生变化，需将inside赋值给outside</span><br><span class=\"line\">        outside = inside  </span><br><span class=\"line\">        let k = index</span><br><span class=\"line\">        while(k&gt;0)&#123;</span><br><span class=\"line\">            if(!inside||!outside) return cur</span><br><span class=\"line\">            inside = inside.next</span><br><span class=\"line\">            outside = outside.next</span><br><span class=\"line\">            k--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(!inside||!outside) return cur</span><br><span class=\"line\">        index++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cur</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"a-href25-k-个一组翻转链表-力扣leetcodehttpsleetcodecnproblemsreverse-nodes-in-k-group-25-k-个一组翻转链表a\"><a class=\"markdownIt-Anchor\" href=\"#a-href25-k-个一组翻转链表-力扣leetcodehttpsleetcodecnproblemsreverse-nodes-in-k-group-25-k-个一组翻转链表a\">#</a> <a href=\"[25. K 个一组翻转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\"> 25. K 个一组翻转链表</a></h3>\n<p>​\t\t这题和上面一样也需要多次反转，我看评论区发现，字节似乎很喜欢考这题，不过老实说这题感觉难度和上面差不多甚至比上题可以还略微简单结果这题是困难上题是一般。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverseKGroup = function(head, k) &#123;</span><br><span class=\"line\">    if(k==1) return head</span><br><span class=\"line\">    let node = new ListNode(0,head),l=node,r=node</span><br><span class=\"line\">    const dfs=(r,num)=&gt;&#123;</span><br><span class=\"line\">    //判断条件有两个一个是剩余链表不足k个这时num大于1，r为空，无需反转。另一个是num为0需反转。</span><br><span class=\"line\">        if(!r) return false</span><br><span class=\"line\">        if(num==0) return</span><br><span class=\"line\">        let res = dfs(r.next,num-1)</span><br><span class=\"line\">        if(res==false)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;else if(res==true)&#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(l.next==r)&#123;</span><br><span class=\"line\">            l.next = l.next.next</span><br><span class=\"line\">            r.next = r.next.next</span><br><span class=\"line\">            l.next.next = r</span><br><span class=\"line\">            r = l</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let temp1 = l.next,temp2=r.next</span><br><span class=\"line\">        l.next=l.next.next</span><br><span class=\"line\">        r.next=r.next.next</span><br><span class=\"line\">        temp2.next = l.next</span><br><span class=\"line\">        l.next = temp2</span><br><span class=\"line\">        temp1.next = r.next</span><br><span class=\"line\">        r.next = temp1</span><br><span class=\"line\">        l = temp2</span><br><span class=\"line\">        if(l==r||l.next==r) return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(r)&#123;</span><br><span class=\"line\">        dfs(r,k)</span><br><span class=\"line\">        //和上面一样递归反转后l的链表会改变，这时需将r赋给l。</span><br><span class=\"line\">        l = r</span><br><span class=\"line\">        let number = k</span><br><span class=\"line\">        while(number&gt;0)&#123;</span><br><span class=\"line\">            if(!l) break</span><br><span class=\"line\">            l = l.next</span><br><span class=\"line\">            r = r.next</span><br><span class=\"line\">            number--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return node.next</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-回文链表\"><a class=\"markdownIt-Anchor\" href=\"#二-回文链表\">#</a> 二、回文链表</h2>\n<h3 id=\"a-hreflcr-027-回文链表-力扣leetcodehttpsleetcodecnproblemsamhzsalcr-027-回文链表a\"><a class=\"markdownIt-Anchor\" href=\"#a-hreflcr-027-回文链表-力扣leetcodehttpsleetcodecnproblemsamhzsalcr-027-回文链表a\">#</a> <a href=\"[LCR 027. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/aMhZSa/)\">LCR 027. 回文链表</a></h3>\n<p>这个没什么好说的，记得外面的链表也要移动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isPalindrome = function(head) &#123;</span><br><span class=\"line\">    let cur = head</span><br><span class=\"line\">    if(!head||!head.next) return true</span><br><span class=\"line\">    const dfs=(list)=&gt;&#123;</span><br><span class=\"line\">        if(!list) return</span><br><span class=\"line\">        let res = dfs(list.next)</span><br><span class=\"line\">        if(res)&#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;else if(res==false)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        if(list.val!=cur.val) return false</span><br><span class=\"line\">        if(cur.next==list||cur.next.next==list) return true</span><br><span class=\"line\">        //记得外面的链表也要往前移动。</span><br><span class=\"line\">        cur=cur.next</span><br><span class=\"line\">         </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return dfs(cur)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-删除链表中满足某个条件的值\"><a class=\"markdownIt-Anchor\" href=\"#三-删除链表中满足某个条件的值\">#</a> 三、删除链表中满足某个条件的值</h2>\n<h3 id=\"a-href83-删除排序链表中的重复元素-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list83-删除排序链表中的重复元素a\"><a class=\"markdownIt-Anchor\" href=\"#a-href83-删除排序链表中的重复元素-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list83-删除排序链表中的重复元素a\">#</a> <a href=\"[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)\">83. 删除排序链表中的重复元素</a></h3>\n<p>递推部分用哈希表获取链表各个值极其个数，回溯部分再根据哈希表删除重复的元素即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map(),cur = head</span><br><span class=\"line\">const dfs =(list)=&gt;&#123;</span><br><span class=\"line\">    // 当链表为空时再return而不是到链表倒数第一位再return，不然的话递推部分会记录倒数第一个值</span><br><span class=\"line\">    if(!list) return</span><br><span class=\"line\">    if(map.has(list.val))&#123;</span><br><span class=\"line\">        map.set(list.val,map.get(list.val)+1)</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        map.set(list.val,1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(list.next)</span><br><span class=\"line\">    if(!list.next) return // 如果是倒数第一个就直接return到上一层也就是倒数第二个，倒数第一个位置删除不了节点。</span><br><span class=\"line\">    let num = map.get(list.next.val)-1</span><br><span class=\"line\">    map.set(list.next.val,num)</span><br><span class=\"line\">    if(num&gt;=1)&#123;</span><br><span class=\"line\">        list.next = list.next.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dfs(cur)</span><br><span class=\"line\">return cur</span><br></pre></td></tr></table></figure>\n<h3 id=\"a-href82-删除排序链表中的重复元素-ii-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list-ii82-删除排序链表中的重复元素-iia\"><a class=\"markdownIt-Anchor\" href=\"#a-href82-删除排序链表中的重复元素-ii-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list-ii82-删除排序链表中的重复元素-iia\">#</a> <a href=\"[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)\">82. 删除排序链表中的重复元素 II</a></h3>\n<p>和上题差不多不过这里头节点可能会删除所以可以整一个虚拟头节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deleteDuplicates = function(head) &#123;</span><br><span class=\"line\">    let map = new Map(),cur = new ListNode(false,head)</span><br><span class=\"line\">    const dfs=(list)=&gt;&#123;</span><br><span class=\"line\">        if(!list)&#123;</span><br><span class=\"line\">            let key = map.keys()</span><br><span class=\"line\">            for(let i of key)&#123;</span><br><span class=\"line\">                if(map.get(i)==1) map.delete(i)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          return  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        if(map.has(list.val))&#123;</span><br><span class=\"line\">            map.set(list.val,map.get(list.val)+1)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            map.set(list.val,1)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(list.next)</span><br><span class=\"line\">        if(!list.next) return</span><br><span class=\"line\">        if(map.has(list.next.val)) list.next =list.next.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(cur)</span><br><span class=\"line\">    return cur.next</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-回文链表-2\"><a class=\"markdownIt-Anchor\" href=\"#二-回文链表-2\">#</a> 二、回文链表</h2>\n<h3 id=\"a-hreflcr-027-回文链表-力扣leetcodehttpsleetcodecnproblemsamhzsalcr-027-回文链表a-2\"><a class=\"markdownIt-Anchor\" href=\"#a-hreflcr-027-回文链表-力扣leetcodehttpsleetcodecnproblemsamhzsalcr-027-回文链表a-2\">#</a> <a href=\"[LCR 027. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/aMhZSa/)\">LCR 027. 回文链表</a></h3>\n<p>这个没什么好说的，记得外面的链表也要移动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var isPalindrome = function(head) &#123;</span><br><span class=\"line\">    let cur = head</span><br><span class=\"line\">    if(!head||!head.next) return true</span><br><span class=\"line\">    const dfs=(list)=&gt;&#123;</span><br><span class=\"line\">        if(!list) return</span><br><span class=\"line\">        let res = dfs(list.next)</span><br><span class=\"line\">        if(res)&#123;</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;else if(res==false)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        if(list.val!=cur.val) return false</span><br><span class=\"line\">        if(cur.next==list||cur.next.next==list) return true</span><br><span class=\"line\">        //记得外面的链表也要往前移动。</span><br><span class=\"line\">        cur=cur.next</span><br><span class=\"line\">         </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    return dfs(cur)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-删除链表中满足某个条件的值-2\"><a class=\"markdownIt-Anchor\" href=\"#三-删除链表中满足某个条件的值-2\">#</a> 三、删除链表中满足某个条件的值</h2>\n<h3 id=\"a-href83-删除排序链表中的重复元素-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list83-删除排序链表中的重复元素a-2\"><a class=\"markdownIt-Anchor\" href=\"#a-href83-删除排序链表中的重复元素-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list83-删除排序链表中的重复元素a-2\">#</a> <a href=\"[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)\">83. 删除排序链表中的重复元素</a></h3>\n<p>递推部分用哈希表获取链表各个值极其个数，回溯部分再根据哈希表删除重复的元素即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map(),cur = head</span><br><span class=\"line\">const dfs =(list)=&gt;&#123;</span><br><span class=\"line\">    // 当链表为空时再return而不是到链表倒数第一位再return，不然的话递推部分会记录倒数第一个值</span><br><span class=\"line\">    if(!list) return</span><br><span class=\"line\">    if(map.has(list.val))&#123;</span><br><span class=\"line\">        map.set(list.val,map.get(list.val)+1)</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        map.set(list.val,1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(list.next)</span><br><span class=\"line\">    if(!list.next) return // 如果是倒数第一个就直接return到上一层也就是倒数第二个，倒数第一个位置删除不了节点。</span><br><span class=\"line\">    let num = map.get(list.next.val)-1</span><br><span class=\"line\">    map.set(list.next.val,num)</span><br><span class=\"line\">    if(num&gt;=1)&#123;</span><br><span class=\"line\">        list.next = list.next.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dfs(cur)</span><br><span class=\"line\">return cur</span><br></pre></td></tr></table></figure>\n<h3 id=\"a-href82-删除排序链表中的重复元素-ii-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list-ii82-删除排序链表中的重复元素-iia-2\"><a class=\"markdownIt-Anchor\" href=\"#a-href82-删除排序链表中的重复元素-ii-力扣leetcodehttpsleetcodecnproblemsremove-duplicates-from-sorted-list-ii82-删除排序链表中的重复元素-iia-2\">#</a> <a href=\"[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)\">82. 删除排序链表中的重复元素 II</a></h3>\n<p>和上题差不多不过这里头节点可能会删除所以可以整一个虚拟头节点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var deleteDuplicates = function(head) &#123;</span><br><span class=\"line\">    let map = new Map(),cur = new ListNode(false,head)</span><br><span class=\"line\">    const dfs=(list)=&gt;&#123;</span><br><span class=\"line\">        if(!list)&#123;</span><br><span class=\"line\">            let key = map.keys()</span><br><span class=\"line\">            for(let i of key)&#123;</span><br><span class=\"line\">                if(map.get(i)==1) map.delete(i)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          return  </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        if(map.has(list.val))&#123;</span><br><span class=\"line\">            map.set(list.val,map.get(list.val)+1)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            map.set(list.val,1)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(list.next)</span><br><span class=\"line\">        if(!list.next) return</span><br><span class=\"line\">        if(map.has(list.next.val)) list.next =list.next.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(cur)</span><br><span class=\"line\">    return cur.next</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"a-href1171-从链表中删去总和值为零的连续节点-力扣leetcodehttpsleetcodecnproblemsremove-zero-sum-consecutive-nodes-from-linked-list1171-从链表中删去总和值为零的连续节点a\"><a class=\"markdownIt-Anchor\" href=\"#a-href1171-从链表中删去总和值为零的连续节点-力扣leetcodehttpsleetcodecnproblemsremove-zero-sum-consecutive-nodes-from-linked-list1171-从链表中删去总和值为零的连续节点a\">#</a> <a href=\"[1171. 从链表中删去总和值为零的连续节点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)\">1171. 从链表中删去总和值为零的连续节点</a></h3>\n<p>前缀和 + 链表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var removeZeroSumSublists = function(head) &#123;</span><br><span class=\"line\">    let arr = [],cur = new ListNode(0,head),index = -1</span><br><span class=\"line\">    const dfs =(list,num)=&gt;&#123;</span><br><span class=\"line\">        if(!list) return  </span><br><span class=\"line\">        if(arr.length!=0)&#123;</span><br><span class=\"line\">            arr.push(arr[num-1]+list.val)</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            arr.push(list.val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(list.next,num+1)</span><br><span class=\"line\">        let k = arr.indexOf(arr[num+1])</span><br><span class=\"line\">        if(k!=num+1&amp;&amp;index==-1) index = k</span><br><span class=\"line\">        if(index!=-1) list.next = list.next.next</span><br><span class=\"line\">        if(index==num) index = -1     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(cur,0)</span><br><span class=\"line\">    return cur.next</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "算法",
                "链表",
                "递归"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/27/Learning-record/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/",
            "url": "https://seele-exzzz.github.io/2023/07/27/Learning-record/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/",
            "title": "JavaScript常用方法",
            "date_published": "2023-07-27T08:18:19.808Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"javascript中常用方法\"><a class=\"markdownIt-Anchor\" href=\"#javascript中常用方法\">#</a> JavaScript 中常用方法</h1>\n<h2 id=\"一-数组\"><a class=\"markdownIt-Anchor\" href=\"#一-数组\">#</a> 一、数组</h2>\n<h3 id=\"1截取数组\"><a class=\"markdownIt-Anchor\" href=\"#1截取数组\">#</a> 1. 截取数组</h3>\n<ol>\n<li>\n<p>slice：获取数组某一区间的元素并形成新的数组将其返回，不改变原数组.</p>\n</li>\n<li>\n<p>splice：删除数组元素同时可以插入元素，会改变原数组.</p>\n<p>slice 方法接收两个参数都为下标，区间为左闭右开。如果省略第一个参数则从第一个元素开始获取如果省略第二个参数则会一直获取到最后一个值。这两个参数都可以是负数。当参数为负数时，最后一个值的下标为 - 1 并以此往前依次减 1. 如果未获取到元素则返回空数组</p>\n<p>splice 方法接收三个参数，第一个参数是要删除值的下标不可省略另外这个参数同样也可以是负数，第二个参数的删除值的个数如果为 0 则不会删除元素，如果省略则一直删到结尾，第三个参数为插入的元素，元素不只是数字或者字符串，数组，函数或者对象都可以传入。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3,4,5,6,7,8,9]</span><br><span class=\"line\">let b = [&#x27;a&#x27;,&#x27;b&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">//获取下标0到2不包括2的元素并返回形成新的数组</span><br><span class=\"line\">console.log(a.slice(0,2))//[ 1, 2 ]</span><br><span class=\"line\">//如果第一个参数没有的话，则从头开始，第二个参数没有的话则获取到结尾//[1, 2, 3, 4, 5,6, 7, 8, 9]</span><br><span class=\"line\">console.log(a.slice())</span><br><span class=\"line\">//获取倒数第三个到倒数第一个不包括倒数第一个元素//[ 7, 8 ]</span><br><span class=\"line\">console.log(a.slice(-3,-1))</span><br><span class=\"line\">let fun= ()=&gt;&#123;return 1&#125;</span><br><span class=\"line\">let obj =&#123;a,b&#125;</span><br><span class=\"line\">a.splice(2,4,obj,fun,...b)//从删除下标2以及之后的3的元素并在2后插入对象函数等元素</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"2查找数组中某一元素的位置\"><a class=\"markdownIt-Anchor\" href=\"#2查找数组中某一元素的位置\">#</a> 2. 查找数组中某一元素的位置</h3>\n<ol>\n<li>\n<p>indexOf： 获取某一元素在数组首次出现的下标。</p>\n</li>\n<li>\n<p>lastIndexOf： 获取某一元素在数组中最后一次出现的下标。</p>\n<p>这两个方法都接收两个参数，第一个参数是要找的值，第二个参数是从那一个下标开始包括此下标（indexOf 向后，lastIndexOf 向前）找，如果没有第二个参数就默认 indexO 从头开始找，lastIndexOf 从最后向前开始找。如果没有找到该元素则返回 - 1</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a =1</span><br><span class=\"line\">const b = [1,2,3,1,2,3,2,1,2,1]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(a)) //0</span><br><span class=\"line\">console.log(b.lastIndexOf(a)) //9</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(a,1)) //3</span><br><span class=\"line\">console.log(b.lastIndexOf(a,8)) //7</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(a,b.indexOf(a)+1)) 获取第二个出现此元素下标</span><br><span class=\"line\">console.log(b.lastIndexOf(a,b.lastIndexOf(a)-1)) 获取倒数第二个出现此元素下标</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(4) //-1</span><br><span class=\"line\">console.log(b.lastIndexOf(4) //-1</span><br></pre></td></tr></table></figure>\n<h3 id=\"3查找数组中满足条件的元素或者下标\"><a class=\"markdownIt-Anchor\" href=\"#3查找数组中满足条件的元素或者下标\">#</a> 3. 查找数组中满足条件的元素或者下标</h3>\n<ol>\n<li>\n<p>find：获取数组中满足条件的元素</p>\n</li>\n<li>\n<p>findIndex：获取数组中满足条件的元素的下标</p>\n<p>这两个方法都接收一个函数做参数，函数有三个参数，第一个为数组的值，第二个为该值在数组中所在的下标，第三个为该数组。其中 find 返回元素，如果没有发现满足条件的元素则返回 undefined，如果有多个元素满足也只会返回第一个满足条件的元素。findIn 返回下标，如果没有发现满足条件的元素则返回 - 1，如果有多个元素满足也只会返回第一个满足条件的下标。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3,4]</span><br><span class=\"line\">console.log(a.find((val)=&gt;val&gt;1)) //2</span><br><span class=\"line\">console.log(a.findIndex((val)=&gt;val&gt;1)) //1 </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"4检查数组中的元素是否存在或者都满足某一条件\"><a class=\"markdownIt-Anchor\" href=\"#4检查数组中的元素是否存在或者都满足某一条件\">#</a> 4. 检查数组中的元素是否存在或者都满足某一条件</h3>\n<ol>\n<li>\n<p>every：检查数组中的元素是否都满足某一条件</p>\n</li>\n<li>\n<p>some：检查数组中的元素是否存在满足某一条件</p>\n<p>这两个方法都接收一个函数做参数，函数有三个参数，第一个为数组的值，第二个为该值在数组中所在的下标，第三个为该数组。返回值均为布尔值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3]</span><br><span class=\"line\">console.log(a.every((val)=&gt;val&gt;0)) //true</span><br><span class=\"line\">console.log(a.every((val)=&gt;val&gt;1)) //false</span><br><span class=\"line\">console.log(a.some((val)=&gt;val&gt;3)) //false</span><br><span class=\"line\">console.log(a.some((val)=&gt;val&gt;1)) //true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"5将数组转化为字符串\"><a class=\"markdownIt-Anchor\" href=\"#5将数组转化为字符串\">#</a> 5. 将数组转化为字符串</h3>\n<ol>\n<li>\n<p>join：获取参数作为分割符，如果没有则默认用‘,’(逗号) 并返回字符串。</p>\n</li>\n<li>\n<p>toString： 将数组转化为字符串并用‘,’(逗号) 分割并返回字符串。</p>\n<p>这两个方法都不会改变原数组</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3]</span><br><span class=\"line\">console.log(a.toString())//1,2,3</span><br><span class=\"line\">console.log(a.join())//1,2,3</span><br><span class=\"line\">console.log(a.join(&#x27;&#x27;))//123</span><br><span class=\"line\">console.log(a.join(&#x27;-&#x27;))//1-2-3</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"6在数组开头或者结尾删除或者添加元素\"><a class=\"markdownIt-Anchor\" href=\"#6在数组开头或者结尾删除或者添加元素\">#</a> 6. 在数组开头或者结尾删除或者添加元素</h3>\n<ol>\n<li>push：向数组末尾添加一个或多个元素，并返回新的长度。</li>\n<li>pop：从数组末尾删除一个元素，并返回被删除的元素。</li>\n<li>shift：从数组开头删除一个元素，并返回被删除的元素。</li>\n<li>unshift：向数组开头添加一个或多个元素，并返回新的长度。</li>\n</ol>\n<h2 id=\"二-字符串\"><a class=\"markdownIt-Anchor\" href=\"#二-字符串\">#</a> 二、字符串</h2>\n<h3 id=\"1字符串转化为数组\"><a class=\"markdownIt-Anchor\" href=\"#1字符串转化为数组\">#</a> 1. 字符串转化为数组</h3>\n<ol>\n<li>\n<p>split：将字符串以某种方式分割成数组。</p>\n<p>split 传入一个参数可以是正则表达式并匹配数组中的元素将其分割为数组，返回一个数组不改变字符串。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str = &#x27;1,3 4&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split()) // 如果不传参数则会将返回一个数组第一个元素为整个字符串</span><br><span class=\"line\">[ &#x27;1,3 4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(&#x27;&#x27;)) // 如果参数为空字符串的话，则会将字符串每一个元素传入数组中并返回这个数组</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;,&#x27;, &#x27;3&#x27;, &#x27; &#x27;, &#x27;4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(&#x27; &#x27;))// 参数可以是空格，将空格作为分割符并传入数组并返回这个数组</span><br><span class=\"line\">[ &#x27;1,3&#x27;, &#x27;4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(&#x27;,&#x27;))</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;3 4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(/[0-9]/))// 参数可以是正则表达式</span><br><span class=\"line\">[ &#x27;&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;&#x27; ]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"2-查找字符串中某个值的位置\"><a class=\"markdownIt-Anchor\" href=\"#2-查找字符串中某个值的位置\">#</a> 2. 查找字符串中某个值的位置</h3>\n<p>1.indexOf：查找某个值在字符串的位置，这个值可以是字符串。</p>\n<p>2.lastIndexOf：查找某个值在字符串的位置，同样这个值可以是字符串。</p>\n<p>用法与数组的方法一致，不过这个方法可以很方便的求两个字符串的子串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str1 = &#x27;abc&#x27;,str2=&#x27;abccbabc&#x27;</span><br><span class=\"line\">console.log(str2.indexOf(str1))//0</span><br><span class=\"line\">console.log(str2.lastIndexOf(str1))//5</span><br><span class=\"line\">只要返回值不是-1就说明str是str2的子串。</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-哈希表\"><a class=\"markdownIt-Anchor\" href=\"#三-哈希表\">#</a> 三、哈希表</h2>\n<ol>\n<li>\n<p>set (key,value): 设置键值对，如果某一键已经存在则会覆盖。第一个参数可以是数字，字符串，布尔值，数组，对象，函数等等值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 =[1,2],obj1=&#123;a:1&#125;,arr2 =[1,2],obj2=&#123;a:1&#125;,map = new Map(),fun1 =()=&gt;&#123;&#125;,fun2=()=&gt;&#123;&#125;</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(obj1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">map.set(obj2,1)</span><br><span class=\"line\">map.set(fun1,1)</span><br><span class=\"line\">map.set(fun2,1)</span><br><span class=\"line\">console.log(map.size)//6</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">let arr1 =[1,2],arr2 =arr1,map = new Map()</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">console.log(map.size)//1</span><br><span class=\"line\"></span><br><span class=\"line\">可以发现像数组，对象，函数尽管一模一样，但是其变量储存的地址不同所以看做是不同的键，但是如果是浅拷贝储存变量的地址一致就视作是同一个键</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>get (key): 获取某一键值在哈希表中的值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">map.get(1)//2</span><br><span class=\"line\">map.get(2)//undefined 如果找不到就会返回undefined</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>has (key): 判断某个键是否存在，并返回布尔值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">console.log(map.has(1))//true</span><br><span class=\"line\">console.log(map.has(2))//false</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>clear (): 清除哈希表所有键值对。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">console.log(map.has(1))//true</span><br><span class=\"line\">map.clear()</span><br><span class=\"line\">console.log(map.has(1))//false</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>delete (key): 删除某键。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">console.log(map.has(1))//true</span><br><span class=\"line\">map.delete()</span><br><span class=\"line\">console.log(map.has(1))//false</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>keys (): 返回一个包含哈希表所有键的迭代器。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 =[1,2],obj1=&#123;a:1&#125;,arr2 =[1,2],obj2=&#123;a:1&#125;,map = new Map(),fun1 =()=&gt;&#123;&#125;,fun2=()=&gt;&#123;&#125;</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(obj1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">map.set(obj2,1)</span><br><span class=\"line\">map.set(fun1,1)</span><br><span class=\"line\">map.set(fun2,1)</span><br><span class=\"line\">let key = map.keys()</span><br><span class=\"line\">for(let i of key)&#123;</span><br><span class=\"line\">    console.log(i) //[ 1, 2 ] &#123; a: 1 &#125; [ 1, 2 ] &#123; a: 1 &#125; [Function: fun1] [Function: fun2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>values (): 返回一个包含哈希表所有值的迭代器。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 =[1,2],obj1=&#123;a:1&#125;,arr2 =[1,2],obj2=&#123;a:1&#125;,map = new Map(),fun1 =()=&gt;&#123;&#125;,fun2=()=&gt;&#123;&#125;</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(obj1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">map.set(obj2,1)</span><br><span class=\"line\">map.set(fun1,1)</span><br><span class=\"line\">map.set(fun2,1)</span><br><span class=\"line\">let val = map.values()</span><br><span class=\"line\">for(let i of val)&#123;</span><br><span class=\"line\">    console.log(i) // 1 1 1 1 1 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n",
            "tags": [
                "学习记录",
                "JavaScript"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/17/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/",
            "url": "https://seele-exzzz.github.io/2023/07/17/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/",
            "title": "链表基础",
            "date_published": "2023-07-17T07:45:02.445Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"链表基础\"><a class=\"markdownIt-Anchor\" href=\"#链表基础\">#</a> 链表基础</h1>\n<h2 id=\"一-链表操作\"><a class=\"markdownIt-Anchor\" href=\"#一-链表操作\">#</a> 一、链表操作</h2>\n<h3 id=\"1力扣上的链表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#1力扣上的链表构造函数\">#</a> 1. 力扣上的链表构造函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意这是力扣上的构造函数不是JavaScript内置函数</span><br><span class=\"line\">function ListNode(val, next) &#123;</span><br><span class=\"line\">    this.val = (val===undefined ? 0 : val)</span><br><span class=\"line\">    this.next = (next===undefined ? null : next)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node = new ListNode(0,head)</span><br><span class=\"line\">//通常用来给链表加上虚拟头结点方便对链表进行操作，第一个形参传值，第二形参传链表</span><br><span class=\"line\">//另外如果用const定义变量再赋予链表，这个变量就无法操作了，原因应该是在操作链表时，链表所储存的变量的地址发生变化。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2链表移动和删除\"><a class=\"markdownIt-Anchor\" href=\"#2链表移动和删除\">#</a> 2. 链表移动和删除</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let cur = head </span><br><span class=\"line\">/*</span><br><span class=\"line\">将head赋给变量cur，如果直接操作head然后再return的话会是null，由于这是浅拷贝，在操作cur时head也会发生改变，所以操作完cur再return head就行。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">cur = cur.next //让将cur下一位赋给cur就完成了一次移动。</span><br><span class=\"line\"></span><br><span class=\"line\">while(cur)&#123;</span><br><span class=\"line\">\t...\t//对cur操作</span><br><span class=\"line\">\tcur = cur.next</span><br><span class=\"line\">&#125; //这就完成了一次遍历，这时cur是null，head已操作</span><br><span class=\"line\"></span><br><span class=\"line\">cur.netx = cur.next.next //想删除那个节点需找到那个节点的前面一个节点，将前面那个节点的指针指向删除节点后面那个节点。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//力扣上203. 移除链表元素</span><br><span class=\"line\"></span><br><span class=\"line\">//方法一，增加虚拟节点</span><br><span class=\"line\">var removeElements = function(head, val) &#123;</span><br><span class=\"line\">    const cur = new ListNode(0,head)</span><br><span class=\"line\">    let a = cur</span><br><span class=\"line\">    while(a.next)&#123;</span><br><span class=\"line\">        if(a.next.val==val)&#123;</span><br><span class=\"line\">            a.next = a.next.next</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            a = a.next </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cur.next</span><br><span class=\"line\">&#125;;//增加虚拟头节点的好处在于，处理原链表的头节点与其他节点的方式一致，无需在额外考虑头节点如何处理，最后只要return cur.next就行。</span><br><span class=\"line\"></span><br><span class=\"line\">//方法二，在不增加虚拟头节点的情况下删除指定节点</span><br><span class=\"line\">var removeElements = function(head, val) &#123;</span><br><span class=\"line\">    let cur = head</span><br><span class=\"line\">    /*先用while将头节点中值等于val删除，之后就和方法一差不多，需要注意的是，删除后有可能是null或者传来的链表就是null，这是需要if条件判断一下，方法一无需判断是因为加了头节点所以不可能是null*/</span><br><span class=\"line\">    while(cur&amp;&amp;cur.val==val)&#123;</span><br><span class=\"line\">        cur = cur.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(!cur) return cur</span><br><span class=\"line\">    head = cur //将处理好的cur赋值给head，如果不赋值，前面的操作就没有用了。</span><br><span class=\"line\">    while(cur.next)&#123;</span><br><span class=\"line\">        if(cur.next.val==val)&#123;</span><br><span class=\"line\">            cur.next = cur.next.next</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3链表的插入\"><a class=\"markdownIt-Anchor\" href=\"#3链表的插入\">#</a> 3. 链表的插入</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//假设需要往链表head中的第n个节点插入val值，注意链表与数组一样下标从0开始</span><br><span class=\"line\">//首先声明一个变量并将head赋值给这个变量</span><br><span class=\"line\">let cur = head</span><br><span class=\"line\"></span><br><span class=\"line\">方法一：不使用虚拟节点</span><br><span class=\"line\"></span><br><span class=\"line\">//如果不使用虚拟节点的话，得分两种情况，第一种删除头节点，第二种删除后面的节点</span><br><span class=\"line\"></span><br><span class=\"line\">//插入头节点</span><br><span class=\"line\">if(n==0)&#123;</span><br><span class=\"line\">\thead = new ListNode(val,head)</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\t//移动到第n-1个节点前</span><br><span class=\"line\">    while(n&gt;1)&#123; //从n减到1，这时cur到n-1节点前，如果加了虚拟头节点，这时的判断条件为0</span><br><span class=\"line\">\t  cur = cur.next</span><br><span class=\"line\">\t  n --</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   let node = new ListNode(val) </span><br><span class=\"line\">   /*注意这里先把cur.next先赋给node.next，如果反过来先让cur.next变成node.next，再让cur.next赋给node.next，这时cur.next已经是node，相当于自己指向自己。这里有点像两个变量交换。假设有a,b两个变量，交换a,b两个变量的值，不用解构赋值的话</span><br><span class=\"line\">   \t let c = a</span><br><span class=\"line\">   \t a = b</span><br><span class=\"line\">   \t b = c</span><br><span class=\"line\">   */</span><br><span class=\"line\">   node.next = cur.next</span><br><span class=\"line\">   cur.next = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">方法二：使用虚拟头节点</span><br><span class=\"line\">let cur = new ListNode(0,head)</span><br><span class=\"line\">let head = cur</span><br><span class=\"line\">while(n)&#123;</span><br><span class=\"line\">\tcur = cur.next</span><br><span class=\"line\">\tn--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node = new ListNode(val)</span><br><span class=\"line\">node.next = cur.next</span><br><span class=\"line\">cur.next = node</span><br><span class=\"line\">head = head.next //最后注意去除虚拟头节点</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "算法",
                "链表"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/14/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/",
            "url": "https://seele-exzzz.github.io/2023/07/14/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/",
            "title": "二叉树基础",
            "date_published": "2023-07-14T14:04:41.779Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"二叉树基础\"><a class=\"markdownIt-Anchor\" href=\"#二叉树基础\">#</a> 二叉树基础</h1>\n<h2 id=\"一-二叉树种类\"><a class=\"markdownIt-Anchor\" href=\"#一-二叉树种类\">#</a> 一、二叉树种类</h2>\n<h3 id=\"1满二叉树\"><a class=\"markdownIt-Anchor\" href=\"#1满二叉树\">#</a> 1. 满二叉树</h3>\n<p>除最后一层有两个子节点外，最后一层没有子节点，如果某个满二叉树有 k 层则该满二叉树有 2 的 k 次方 - 1 个节点。</p>\n<h3 id=\"2-完全二叉树\"><a class=\"markdownIt-Anchor\" href=\"#2-完全二叉树\">#</a> 2. 完全二叉树</h3>\n<p>最后一层如果有缺的子节点则该子节点为右侧的子节点。如果某个完全二叉树有 k 层，则该完全二叉树则有 2 的 k-1 次方到 2 的 k 次方 - 1 个节点。满二叉树是特殊的完全二叉树</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"\"></p>\n<h3 id=\"3-二叉搜索树\"><a class=\"markdownIt-Anchor\" href=\"#3-二叉搜索树\">#</a> 3. 二叉搜索树</h3>\n<p>二叉搜索树中某个节点的左节点值小于该节点，右节点值大于该节点</p>\n<h3 id=\"4-二叉平衡树\"><a class=\"markdownIt-Anchor\" href=\"#4-二叉平衡树\">#</a> 4. 二叉平衡树</h3>\n<p>在二叉搜索树的条件下，每一个节点的左子树与右子树的高度差不大于一，二叉平衡树是特殊的二叉搜索树。另外二叉树的高度从下往上数，深度从上往下数。</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91.png\" alt=\"\"></p>\n<h2 id=\"二-二叉树的构建\"><a class=\"markdownIt-Anchor\" href=\"#二-二叉树的构建\">#</a> 二、 二叉树的构建</h2>\n<h3 id=\"1-构建力扣上的二叉树\"><a class=\"markdownIt-Anchor\" href=\"#1-构建力扣上的二叉树\">#</a> 1. 构建力扣上的二叉树</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在做力扣上102. 二叉树的层序遍历的时候，好奇试了一下console.dir(root)</span><br><span class=\"line\">TreeNode &#123;</span><br><span class=\"line\">  val: 3,</span><br><span class=\"line\">  left: TreeNode &#123; val: 9, left: null, right: null &#125;,</span><br><span class=\"line\">  right: TreeNode &#123;</span><br><span class=\"line\">    val: 20,</span><br><span class=\"line\">    left: TreeNode &#123; val: 15, left: null, right: null &#125;,</span><br><span class=\"line\">    right: TreeNode &#123; val: 7, left: null, right: null &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;// 结果是这个，根据这个我试着构建了一下二叉树，当然后面看别人的文章发现二叉树远不止这些属性和方法</span><br><span class=\"line\">class TreeNode &#123;</span><br><span class=\"line\">    constructor(val) &#123;</span><br><span class=\"line\">      this.val = val;</span><br><span class=\"line\">      this.left = null;</span><br><span class=\"line\">      this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addleft(left)&#123;</span><br><span class=\"line\">        this.left = left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addright(right)&#123;</span><br><span class=\"line\">        this.right = right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const root = new TreeNode(3)</span><br><span class=\"line\">root.addleft(new TreeNode(9))</span><br><span class=\"line\">root.addright(new TreeNode(20))</span><br><span class=\"line\">root.right.addleft(new TreeNode(15))</span><br><span class=\"line\">root.right.addright(new TreeNode(7))</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-二叉树的遍历\"><a class=\"markdownIt-Anchor\" href=\"#三-二叉树的遍历\">#</a> 三、二叉树的遍历</h2>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/cover/algorithm/binary_tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png\" alt=\"\"></p>\n<h3 id=\"1-深度优先算法\"><a class=\"markdownIt-Anchor\" href=\"#1-深度优先算法\">#</a> 1. 深度优先算法</h3>\n<h4 id=\"1-递归法\"><a class=\"markdownIt-Anchor\" href=\"#1-递归法\">#</a> 1. 递归法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//root为二叉树</span><br><span class=\"line\">const result =[]</span><br><span class=\"line\">const dfs = (root)=&gt;&#123;</span><br><span class=\"line\">    if(root==null) return</span><br><span class=\"line\">    //前序遍历</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    //中序遍历</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    //后序遍历</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dfs(root)</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-迭代法\"><a class=\"markdownIt-Anchor\" href=\"#2-迭代法\">#</a> 2. 迭代法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//前序遍历</span><br><span class=\"line\">const result =[],arr=[root]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let tree = arr.pop()</span><br><span class=\"line\">    if(tree==null) continue</span><br><span class=\"line\">    result.push(tree.val)</span><br><span class=\"line\">\tarr.push(tree.right)</span><br><span class=\"line\">    arr.push(tree.left)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br><span class=\"line\">//后序遍历 在前序遍历的情况下调换调换传入arr的两个子节点，同时将最后的数组反转。</span><br><span class=\"line\">const result =[],arr=[root]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let tree = arr.pop()</span><br><span class=\"line\">    if(tree==null) continue</span><br><span class=\"line\">    result.push(tree.val)</span><br><span class=\"line\">    arr.push(tree.left)</span><br><span class=\"line\">    arr.push(tree.right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result.reverse()</span><br><span class=\"line\">//中序遍历</span><br><span class=\"line\">const result =[],stack=[]</span><br><span class=\"line\">let tree = root</span><br><span class=\"line\">while(stack.length&gt;0||tree)&#123;</span><br><span class=\"line\">\tif(tree)&#123;</span><br><span class=\"line\">\t\tstack.push(tree)</span><br><span class=\"line\">\t\ttree = tree.left</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tlet rootTree = stack.pop()</span><br><span class=\"line\">\t\tresult.push(rootTree.val)</span><br><span class=\"line\">\t\ttree = rootTree.right</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-广度优先搜索span-stylefont-size16px层序遍历span\"><a class=\"markdownIt-Anchor\" href=\"#2-广度优先搜索span-stylefont-size16px层序遍历span\">#</a> 2. 广度优先搜索<span style=\"font-size:16px\">(层序遍历)</span></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//力扣上的层序遍历最后的输出结果似乎都是二维数组，需要将每一层的值用数组储存然后将其储存进一个数组输出出去。</span><br><span class=\"line\">const result = [],arr=[root]</span><br><span class=\"line\">let res=[]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let len = arr.length //相当于快照用于储存当前层数的长度。</span><br><span class=\"line\">    while(len&gt;0)&#123; //当len为零时，说明当前层的值已全部弹出，这时应该用result储存当前层所有数组</span><br><span class=\"line\">        let tree = arr.shift() </span><br><span class=\"line\">        len -- </span><br><span class=\"line\">        if(tree!=null)&#123;</span><br><span class=\"line\">            res.push(tree.val)</span><br><span class=\"line\">            arr.push(tree.left)</span><br><span class=\"line\">            arr.push(tree.right)  </span><br><span class=\"line\">        &#125;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(res.length==0) break </span><br><span class=\"line\">    result.push(res) </span><br><span class=\"line\">    res = [] //清空当前层用于记录下一层的值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "二叉树",
                "算法"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/12/Learning-record/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "url": "https://seele-exzzz.github.io/2023/07/12/Learning-record/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "title": "正则学习记录",
            "date_published": "2023-07-12T05:31:15.886Z",
            "content_html": "<h1 id=\"正则学习记录\"><a class=\"markdownIt-Anchor\" href=\"#正则学习记录\">#</a> 正则学习记录</h1>\n<p>[toc]</p>\n<h2 id=\"一-正则表达式的创建\"><a class=\"markdownIt-Anchor\" href=\"#一-正则表达式的创建\">#</a> 一、正则表达式的创建</h2>\n<h3 id=\"1-字面量创建\"><a class=\"markdownIt-Anchor\" href=\"#1-字面量创建\">#</a> 1. 字面量创建</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = /a/igm //i表示忽略大小写，g表示全局匹配，m表示多行匹配</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-构造函数创建\"><a class=\"markdownIt-Anchor\" href=\"#2-构造函数创建\">#</a> 2. 构造函数创建</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt a = &#x27;a&#x27;</span><br><span class=\"line\">const b = new RegExp(&#x27;a&#x27;) 或者 b = new RegExp(a)//这里的b打印结果与上面字面量创建的a一致</span><br><span class=\"line\">// RegExp有两个参数，第一个参数传入一个字符串表示正则表达式，第二个参数有g全局匹配，i忽略大小写，m多行匹配</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-javascript中正则方法\"><a class=\"markdownIt-Anchor\" href=\"#二-javascript中正则方法\">#</a> 二、JavaScript 中正则方法</h2>\n<h3 id=\"1-test方法\"><a class=\"markdownIt-Anchor\" href=\"#1-test方法\">#</a> 1. test 方法</h3>\n<p>用于测试某一字符串是否满足某一正则表达式，返回一个布尔值。正则表达式的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const str = &#x27;abc&#x27;</span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-exec方法\"><a class=\"markdownIt-Anchor\" href=\"#2-exec方法\">#</a> 2. exec 方法</h3>\n<p>用于匹配某一字符串中满足正则表达式的内容，返回一个数组，第一项为匹配到的内容，第二项 index 为匹配到内容第一个字符所在的索引，input 为匹配的字符串，groups 为命名的捕获组。正则表达式的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const str = &#x27;abcabcaa&#x27;</span><br><span class=\"line\">const result = reg.exec(str)</span><br><span class=\"line\">console.log(result) //[ &#x27;a&#x27;, index: 0, input: &#x27;abcabcaa&#x27;, groups: undefined ]</span><br><span class=\"line\">/*</span><br><span class=\"line\">\t如果正则表达式是全局匹配的话，exec会改变的lastindex，如果exec没匹配上，这时lastindexhi变为0</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reg = /a/g</span><br><span class=\"line\">const str = &#x27;abac&#x27;</span><br><span class=\"line\">for(let i=0;i&lt;3;i++)&#123;</span><br><span class=\"line\">\tconsole.log(reg.lastIndex)</span><br><span class=\"line\">    reg.exec(str)</span><br><span class=\"line\">    console.log(reg.lastIndex)</span><br><span class=\"line\">&#125;// 0,1,1,3,3,0</span><br><span class=\"line\">//可以用?&lt;name&gt;给捕获组命名。这时如果成功匹配返回的对象中groups不再是undefined而是一个属性为捕获组名字，值为匹配到的内容的对象。</span><br><span class=\"line\">const reg = /(?&lt;year&gt;[0-9]+)-(?&lt;month&gt;[0-9]+)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span><br><span class=\"line\">const str = &#x27;2023-07-13&#x27;</span><br><span class=\"line\">const result = reg.exec(str)</span><br><span class=\"line\">console.log(result)</span><br><span class=\"line\">/*</span><br><span class=\"line\">[</span><br><span class=\"line\">  &#x27;2023-07-13&#x27;,</span><br><span class=\"line\">  &#x27;2023&#x27;,</span><br><span class=\"line\">  &#x27;07&#x27;,</span><br><span class=\"line\">  &#x27;13&#x27;,</span><br><span class=\"line\">  index: 0,</span><br><span class=\"line\">  input: &#x27;2023-07-13&#x27;,</span><br><span class=\"line\">  groups: [Object: null prototype] &#123; year: \t &#x27;2023&#x27;, month: &#x27;07&#x27;, day: &#x27;13&#x27; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reg = /(?&lt;year&gt;[0-9]+)-(?&lt;month&gt;[0-9]+)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span><br><span class=\"line\">const str = &#x27;2023-07-13 1145-14-15&#x27;</span><br><span class=\"line\">reg.exec(str).groups</span><br><span class=\"line\">const &#123;year,month,day&#125; = reg.exec(str).groups</span><br><span class=\"line\">console.log(year,month,day) // 1145 14 15</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-match方法\"><a class=\"markdownIt-Anchor\" href=\"#3-match方法\">#</a> 3. match 方法</h3>\n<p>匹配字符串中满足正则表达式的内容并返回一个数组，注意 match 是字符串的方法不是正则表达式的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;abcabcaa&#x27;</span><br><span class=\"line\">const result = str.match(reg) // 如果正则表达式不是全局匹配这时match返回值与exec一致</span><br><span class=\"line\">console.log(result)//[ &#x27;a&#x27;, index: 0, input: &#x27;abcabcaa&#x27;, groups: undefined ]</span><br><span class=\"line\">const resultG = str.match(regG)// 这时会返回一个数组，数组中每一项为满足字符串中满足正则表达式中匹配规则的部分。</span><br><span class=\"line\">console.log(resultG)//[ &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27; ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-search方法\"><a class=\"markdownIt-Anchor\" href=\"#4-search方法\">#</a> 4. search 方法</h3>\n<p>匹配字符串中满足正则表达式的内容并返回第一个匹配到字符的索引。同样这也是字符串方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;babcabcaa&#x27;</span><br><span class=\"line\">const result = str.search(reg) </span><br><span class=\"line\">const resultG = str.search(regG)// 全局匹配一样只返回匹配到第一个满足条件的字符的索引</span><br><span class=\"line\">console.log(result)//1</span><br><span class=\"line\">console.log(resultG)//1</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-replace方法\"><a class=\"markdownIt-Anchor\" href=\"#5-replace方法\">#</a> 5. replace () 方法</h3>\n<p>匹配字符串中满足某字符串或者正则表达式的内容并进行替换，同样也是字符串方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;babcabcaa&#x27;</span><br><span class=\"line\">const result = str.replace(reg,&#x27;*&#x27;) //没有全局匹配只匹配第一个满足条件的</span><br><span class=\"line\">const resultG = str.replace(regG,&#x27;*&#x27;)</span><br><span class=\"line\">console.log(result) //b*bcabcaa</span><br><span class=\"line\">console.log(resultG) //b*bc*bc**</span><br><span class=\"line\">/*</span><br><span class=\"line\">\treplace的第二个参数可以传递一个函数，函数的参数为匹配到的内容，如果正则表达式是全局匹配的话且能匹配到多个字符，则每匹配到一个就会调用一次函数，形参为匹配到的内容</span><br><span class=\"line\">*/</span><br><span class=\"line\">const result = str.replace(reg,(data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data) // a </span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">const resultG = str.replace(regG,(data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data) // a</span><br><span class=\"line\">&#125;) //回调函数调用了3次</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-split方法\"><a class=\"markdownIt-Anchor\" href=\"#6-split方法\">#</a> 6. split 方法</h3>\n<p>用字符串分割数组，分割方式可以为一个正则表达式并返回一个数组，数组每一项为分割后的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &#x27;abc&#x27;</span><br><span class=\"line\">const newstr = str.split(&#x27;&#x27;)</span><br><span class=\"line\">console.log(newstr) //[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span><br><span class=\"line\">/*</span><br><span class=\"line\">\tJavaScript中字符串的方法有限，如果想要反转字符串，简单的办法是用split(&#x27;&#x27;)转化为数\t组然后调用reverse方法反转数组并调用join(&#x27;&#x27;)转回字符串</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reStr = str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) </span><br><span class=\"line\">console.log(reStr) // cba</span><br><span class=\"line\"></span><br><span class=\"line\">const str = &#x27;2023-7-12&#x27; //如果想要这个字符串中的数字</span><br><span class=\"line\">const newstr = str.split(/-/)</span><br><span class=\"line\">console.log(newstr) [ &#x27;2023&#x27;, &#x27;7&#x27;, &#x27;12&#x27; ]</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "学习记录",
                "正则"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/08/Learning-record/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "url": "https://seele-exzzz.github.io/2023/07/08/Learning-record/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "title": "Typescript学习记录",
            "date_published": "2023-07-08T10:22:13.494Z",
            "content_html": "<h1 id=\"typescript学习记录\"><a class=\"markdownIt-Anchor\" href=\"#typescript学习记录\">#</a> Typescript 学习记录</h1>\n<p>[toc]</p>\n<h2 id=\"一-基本类型\"><a class=\"markdownIt-Anchor\" href=\"#一-基本类型\">#</a> 一、基本类型</h2>\n<h3 id=\"1-基本数据类型span-stylefont-size14px-type代表类型span\"><a class=\"markdownIt-Anchor\" href=\"#1-基本数据类型span-stylefont-size14px-type代表类型span\">#</a> 1. 基本数据类型<span style='font-size:14px' >(type 代表类型)</span></h3>\n<ul>\n<li>any: 任意类型</li>\n<li>string: 字符串类型</li>\n<li>boolean: 布尔类型</li>\n<li>type[]，Array<type>: 数组类型两种表示方法</li>\n<li>[type] : 元组，如果要储存类似经纬度这类需要两个数字的数据则可以用 [number,number]</li>\n<li>void : 表示函数无返回值</li>\n<li>null : null 类型</li>\n<li>undefined : undefined 类型</li>\n<li>never : 表示从来不会出现的值</li>\n</ul>\n<h3 id=\"2-函数形参和返回值的类型\"><a class=\"markdownIt-Anchor\" href=\"#2-函数形参和返回值的类型\">#</a> 2. 函数形参和返回值的类型</h3>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>):<span class=\"function\"><span class=\"params\">string</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;<span class=\"comment\">//void 表示无返回值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-类型推断\"><a class=\"markdownIt-Anchor\" href=\"#3-类型推断\">#</a> 3. 类型推断</h3>\n<p>ide 在编译文件时会对变量的类型进行判断，所以在声明一个变量后立马赋值，声明一个对象并对其中的属性赋值又或者函数的返回值与形参有关可以推断出来等等，这些可以推断出来的就无需加上类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span> <span class=\"comment\">//ide会推断这个变量a的类型为number类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a : <span class=\"number\">1</span> <span class=\"comment\">//同样ide会推断这个a属性为number类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b <span class=\"comment\">//ide会推断这里的返回值为string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-关键字type和联合类型\"><a class=\"markdownIt-Anchor\" href=\"#4-关键字type和联合类型\">#</a> 4. 关键字 type 和联合类型</h3>\n<p>利用 type 给类型取一个别名，type 可以与联合类型一起使用</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> str1 = <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>:str1</span><br><span class=\"line\"><span class=\"keyword\">type</span> t = <span class=\"built_in\">number</span> | str1</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>:t</span><br><span class=\"line\"><span class=\"keyword\">type</span> funType = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">fun</span> = (<span class=\"params\">a:funType</span>)=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-接口\"><a class=\"markdownIt-Anchor\" href=\"#二-接口\">#</a> 二、接口</h2>\n<p>如果一个对象会重复使用，则可以使用将其抽出写成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//接口与对象不同，属性之间可不加逗号</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">b</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-接口属性\"><a class=\"markdownIt-Anchor\" href=\"#1-接口属性\">#</a> 1. 接口属性</h3>\n<ul>\n<li>可选属性：如果函数的形参对象中的某些属性是可选的。比如在使用 axios 时，传入的配置对象中 method 属性是可选属性如果不传默认是 get。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    a?:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//a是可选属性，可不传。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">b</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(&#123;a=<span class=\"number\">1</span>,b&#125;:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125; <span class=\"comment\">//如果想给a一个默认值，如果没传就使用默认值的话</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>只读属性：如果接口中的某些属性不可修改，只读的话则可以使用只读属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">readonly</span> <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">   <span class=\"keyword\">readonly</span> <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(&#123;a,b&#125;:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引类型：索引签名允许我们定义一个可以包含不同属性名称的动态对象并且固定属性的类型必须与索引类型相同或是其子级。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">    [<span class=\"attr\">propName</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">abc</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "学习记录",
                "typescript"
            ]
        }
    ]
}