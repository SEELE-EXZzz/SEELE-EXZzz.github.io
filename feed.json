{
    "version": "https://jsonfeed.org/version/1",
    "title": "个人博客",
    "subtitle": "",
    "icon": "https://seele-exzzz.github.io/assets/favicon.ico",
    "description": "",
    "home_page_url": "https://seele-exzzz.github.io",
    "items": [
        {
            "id": "https://seele-exzzz.github.io/2023/08/03/project/electron-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAelectron%E9%A1%B9%E7%9B%AE/",
            "url": "https://seele-exzzz.github.io/2023/08/03/project/electron-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAelectron%E9%A1%B9%E7%9B%AE/",
            "title": "electron配置",
            "date_published": "2023-08-03T07:04:45.388Z",
            "content_html": "<h1 id=\"electron-从零搭建一个electron项目\"><a class=\"markdownIt-Anchor\" href=\"#electron-从零搭建一个electron项目\">#</a> electron - 从零搭建一个 electron 项目</h1>\n",
            "tags": [
                "项目",
                "vue",
                "electron",
                "element-ui",
                "项目"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/08/02/algorithm/%E9%93%BE%E8%A1%A8%E8%BF%9B%E9%98%B6-%E8%AE%BA%E9%80%92%E5%BD%92%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/",
            "url": "https://seele-exzzz.github.io/2023/08/02/algorithm/%E9%93%BE%E8%A1%A8%E8%BF%9B%E9%98%B6-%E8%AE%BA%E9%80%92%E5%BD%92%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/",
            "title": "链表进阶",
            "date_published": "2023-08-02T13:31:36.133Z",
            "content_html": "<h1 id=\"链表进阶-论递归在链表中的作用\"><a class=\"markdownIt-Anchor\" href=\"#链表进阶-论递归在链表中的作用\">#</a> 链表进阶 - 论递归在链表中的作用</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>初次接触链表的时候，一方面在改变指针的时候容易出现问题导致链表出现环，当然之后只要涉及改变指针就靠画图理顺指针改变顺序解决了这个问题，另一方面链表与数组不一样的点在于链表无法回退，这时递归登场了，因为递归有回溯的过程，所以只要将链表的下一项当作参数，那么在回溯的时候自然就会进行回退。使用递归能很轻松地解决蛮多链表的问题。以下是一些用递归解决链表的类型题目。</p>\n<h2 id=\"一-反转链表\"><a class=\"markdownIt-Anchor\" href=\"#一-反转链表\">#</a> 一 、反转链表</h2>\n<p>这类型题目主要是需要在外面设置一个变量储存链表，然后将链表的下一项当作递归的参数，当到达要交换的最后一个节点时就要 return，然后在回溯的部分交换，外面的链表记得在交换后往前走，里面的链表在返回上一层函数的时候会自动回退，这就起到了前后交换节点的操作。</p>\n<h3 id=\"a-href剑指-offer-ii-024-反转链表-力扣leetcodehttpsleetcodecnproblemsuhnkqh剑指-offer-ii-024-反转链表a\"><a class=\"markdownIt-Anchor\" href=\"#a-href剑指-offer-ii-024-反转链表-力扣leetcodehttpsleetcodecnproblemsuhnkqh剑指-offer-ii-024-反转链表a\">#</a> <a href=\"[剑指 Offer II 024. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/UHnkqh/)\">剑指 Offer II 024. 反转链表</a></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var reverseList = function(head) &#123;</span><br><span class=\"line\">    if(!head||!head.next) return head //如果链表为空或者只有一项return原链表就行</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    \t这里用到了虚拟头节点，因为第一个头节点也要交换如果设置虚拟头节点方便交换头节点，另外也需要在外面设置一个变量一个正向移动，另一个在回溯中逆向移动两个交换节点就能实现链表反转。</span><br><span class=\"line\">    */</span><br><span class=\"line\">    let cur = new ListNode(0,head),node = cur</span><br><span class=\"line\">    const dfs=(list)=&gt;&#123;</span><br><span class=\"line\">    \t//因为最后一个节点要交换，交换节点需要到前一个节点，所以这里到最后一个节点就return这样回溯部分就从倒二个节点开始回退</span><br><span class=\"line\">        if(!list.next) return</span><br><span class=\"line\">        //一旦交换成功就return true，一旦return的结果是true就立马return true防止继续进行回溯部分。导致已经交换过的节点继续交换。</span><br><span class=\"line\">        if(dfs(list.next)) return true </span><br><span class=\"line\">        //最后一次交换有两种情况，一种就是这个，交换节点挨着。</span><br><span class=\"line\">        if(cur.next==list)&#123;</span><br><span class=\"line\">            let temp = cur.next</span><br><span class=\"line\">            cur.next = cur.next.next</span><br><span class=\"line\">            temp.next = cur.next.next</span><br><span class=\"line\">            cur.next.next = temp</span><br><span class=\"line\">            return true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //大部分交换时，交换的节点都隔着节点</span><br><span class=\"line\">        let temp1 = cur.next,temp2=list.next</span><br><span class=\"line\">        cur.next = cur.next.next</span><br><span class=\"line\">        list.next = list.next.next</span><br><span class=\"line\">        temp2.next = cur.next</span><br><span class=\"line\">        cur.next = temp2</span><br><span class=\"line\">        temp1.next = list.next</span><br><span class=\"line\">        list.next = temp1</span><br><span class=\"line\">        cur = temp2</span><br><span class=\"line\">        //如果要交换的节点之间隔着一个节点，交换后cur的下个节点就是list这时该赶紧return。</span><br><span class=\"line\">        if(cur.next==list) return true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(node)</span><br><span class=\"line\">    return node.next //最后return记得不要带上自己设置的虚拟头节点。</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "算法",
                "链表",
                "递归"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/27/Learning-record/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/",
            "url": "https://seele-exzzz.github.io/2023/07/27/Learning-record/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/",
            "title": "JavaScript常用方法",
            "date_published": "2023-07-27T08:18:19.808Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"javascript中常用方法\"><a class=\"markdownIt-Anchor\" href=\"#javascript中常用方法\">#</a> JavaScript 中常用方法</h1>\n<h2 id=\"一-数组\"><a class=\"markdownIt-Anchor\" href=\"#一-数组\">#</a> 一、数组</h2>\n<h3 id=\"1截取数组\"><a class=\"markdownIt-Anchor\" href=\"#1截取数组\">#</a> 1. 截取数组</h3>\n<ol>\n<li>\n<p>slice：获取数组某一区间的元素并形成新的数组将其返回，不改变原数组.</p>\n</li>\n<li>\n<p>splice：删除数组元素同时可以插入元素，会改变原数组.</p>\n<p>slice 方法接收两个参数都为下标，区间为左闭右开。如果省略第一个参数则从第一个元素开始获取如果省略第二个参数则会一直获取到最后一个值。这两个参数都可以是负数。当参数为负数时，最后一个值的下标为 - 1 并以此往前依次减 1. 如果未获取到元素则返回空数组</p>\n<p>splice 方法接收三个参数，第一个参数是要删除值的下标不可省略另外这个参数同样也可以是负数，第二个参数的删除值的个数如果为 0 则不会删除元素，如果省略则一直删到结尾，第三个参数为插入的元素，元素不只是数字或者字符串，数组，函数或者对象都可以传入。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3,4,5,6,7,8,9]</span><br><span class=\"line\">let b = [&#x27;a&#x27;,&#x27;b&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\">//获取下标0到2不包括2的元素并返回形成新的数组</span><br><span class=\"line\">console.log(a.slice(0,2))//[ 1, 2 ]</span><br><span class=\"line\">//如果第一个参数没有的话，则从头开始，第二个参数没有的话则获取到结尾//[1, 2, 3, 4, 5,6, 7, 8, 9]</span><br><span class=\"line\">console.log(a.slice())</span><br><span class=\"line\">//获取倒数第三个到倒数第一个不包括倒数第一个元素//[ 7, 8 ]</span><br><span class=\"line\">console.log(a.slice(-3,-1))</span><br><span class=\"line\">let fun= ()=&gt;&#123;return 1&#125;</span><br><span class=\"line\">let obj =&#123;a,b&#125;</span><br><span class=\"line\">a.splice(2,4,obj,fun,...b)//从删除下标2以及之后的3的元素并在2后插入对象函数等元素</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"2查找数组中某一元素的位置\"><a class=\"markdownIt-Anchor\" href=\"#2查找数组中某一元素的位置\">#</a> 2. 查找数组中某一元素的位置</h3>\n<ol>\n<li>\n<p>indexOf： 获取某一元素在数组首次出现的下标。</p>\n</li>\n<li>\n<p>lastIndexOf： 获取某一元素在数组中最后一次出现的下标。</p>\n<p>这两个方法都接收两个参数，第一个参数是要找的值，第二个参数是从那一个下标开始包括此下标（indexOf 向后，lastIndexOf 向前）找，如果没有第二个参数就默认 indexO 从头开始找，lastIndexOf 从最后向前开始找。如果没有找到该元素则返回 - 1</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a =1</span><br><span class=\"line\">const b = [1,2,3,1,2,3,2,1,2,1]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(a)) //0</span><br><span class=\"line\">console.log(b.lastIndexOf(a)) //9</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(a,1)) //3</span><br><span class=\"line\">console.log(b.lastIndexOf(a,8)) //7</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(a,b.indexOf(a)+1)) 获取第二个出现此元素下标</span><br><span class=\"line\">console.log(b.lastIndexOf(a,b.lastIndexOf(a)-1)) 获取倒数第二个出现此元素下标</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b.indexOf(4) //-1</span><br><span class=\"line\">console.log(b.lastIndexOf(4) //-1</span><br></pre></td></tr></table></figure>\n<h3 id=\"3查找数组中满足条件的元素或者下标\"><a class=\"markdownIt-Anchor\" href=\"#3查找数组中满足条件的元素或者下标\">#</a> 3. 查找数组中满足条件的元素或者下标</h3>\n<ol>\n<li>\n<p>find：获取数组中满足条件的元素</p>\n</li>\n<li>\n<p>findIndex：获取数组中满足条件的元素的下标</p>\n<p>这两个方法都接收一个函数做参数，函数有三个参数，第一个为数组的值，第二个为该值在数组中所在的下标，第三个为该数组。其中 find 返回元素，如果没有发现满足条件的元素则返回 undefined，如果有多个元素满足也只会返回第一个满足条件的元素。findIn 返回下标，如果没有发现满足条件的元素则返回 - 1，如果有多个元素满足也只会返回第一个满足条件的下标。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3,4]</span><br><span class=\"line\">console.log(a.find((val)=&gt;val&gt;1)) //2</span><br><span class=\"line\">console.log(a.findIndex((val)=&gt;val&gt;1)) //1 </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"4检查数组中的元素是否存在或者都满足某一条件\"><a class=\"markdownIt-Anchor\" href=\"#4检查数组中的元素是否存在或者都满足某一条件\">#</a> 4. 检查数组中的元素是否存在或者都满足某一条件</h3>\n<ol>\n<li>\n<p>every：检查数组中的元素是否都满足某一条件</p>\n</li>\n<li>\n<p>some：检查数组中的元素是否存在满足某一条件</p>\n<p>这两个方法都接收一个函数做参数，函数有三个参数，第一个为数组的值，第二个为该值在数组中所在的下标，第三个为该数组。返回值均为布尔值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3]</span><br><span class=\"line\">console.log(a.every((val)=&gt;val&gt;0)) //true</span><br><span class=\"line\">console.log(a.every((val)=&gt;val&gt;1)) //false</span><br><span class=\"line\">console.log(a.some((val)=&gt;val&gt;3)) //false</span><br><span class=\"line\">console.log(a.some((val)=&gt;val&gt;1)) //true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"5将数组转化为字符串\"><a class=\"markdownIt-Anchor\" href=\"#5将数组转化为字符串\">#</a> 5. 将数组转化为字符串</h3>\n<ol>\n<li>\n<p>join：获取参数作为分割符，如果没有则默认用‘,’(逗号) 并返回字符串。</p>\n</li>\n<li>\n<p>toString： 将数组转化为字符串并用‘,’(逗号) 分割并返回字符串。</p>\n<p>这两个方法都不会改变原数组</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = [1,2,3]</span><br><span class=\"line\">console.log(a.toString())//1,2,3</span><br><span class=\"line\">console.log(a.join())//1,2,3</span><br><span class=\"line\">console.log(a.join(&#x27;&#x27;))//123</span><br><span class=\"line\">console.log(a.join(&#x27;-&#x27;))//1-2-3</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"6在数组开头或者结尾删除或者添加元素\"><a class=\"markdownIt-Anchor\" href=\"#6在数组开头或者结尾删除或者添加元素\">#</a> 6. 在数组开头或者结尾删除或者添加元素</h3>\n<ol>\n<li>push：向数组末尾添加一个或多个元素，并返回新的长度。</li>\n<li>pop：从数组末尾删除一个元素，并返回被删除的元素。</li>\n<li>shift：从数组开头删除一个元素，并返回被删除的元素。</li>\n<li>unshift：向数组开头添加一个或多个元素，并返回新的长度。</li>\n</ol>\n<h2 id=\"二-字符串\"><a class=\"markdownIt-Anchor\" href=\"#二-字符串\">#</a> 二、字符串</h2>\n<h3 id=\"1字符串转化为数组\"><a class=\"markdownIt-Anchor\" href=\"#1字符串转化为数组\">#</a> 1. 字符串转化为数组</h3>\n<ol>\n<li>\n<p>split：将字符串以某种方式分割成数组。</p>\n<p>split 传入一个参数可以是正则表达式并匹配数组中的元素将其分割为数组，返回一个数组不改变字符串。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str = &#x27;1,3 4&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split()) // 如果不传参数则会将返回一个数组第一个元素为整个字符串</span><br><span class=\"line\">[ &#x27;1,3 4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(&#x27;&#x27;)) // 如果参数为空字符串的话，则会将字符串每一个元素传入数组中并返回这个数组</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;,&#x27;, &#x27;3&#x27;, &#x27; &#x27;, &#x27;4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(&#x27; &#x27;))// 参数可以是空格，将空格作为分割符并传入数组并返回这个数组</span><br><span class=\"line\">[ &#x27;1,3&#x27;, &#x27;4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(&#x27;,&#x27;))</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;3 4&#x27; ]</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(str.split(/[0-9]/))// 参数可以是正则表达式</span><br><span class=\"line\">[ &#x27;&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;&#x27; ]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"三-哈希表\"><a class=\"markdownIt-Anchor\" href=\"#三-哈希表\">#</a> 三、哈希表</h2>\n<ol>\n<li>\n<p>set (key,value): 设置键值对，如果某一键已经存在则会覆盖。第一个参数可以是数字，字符串，布尔值，数组，对象，函数等等值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 =[1,2],obj1=&#123;a:1&#125;,arr2 =[1,2],obj2=&#123;a:1&#125;,map = new Map(),fun1 =()=&gt;&#123;&#125;,fun2=()=&gt;&#123;&#125;</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(obj1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">map.set(obj2,1)</span><br><span class=\"line\">map.set(fun1,1)</span><br><span class=\"line\">map.set(fun2,1)</span><br><span class=\"line\">console.log(map.size)//6</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">let arr1 =[1,2],arr2 =arr1,map = new Map()</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">console.log(map.size)//1</span><br><span class=\"line\"></span><br><span class=\"line\">可以发现像数组，对象，函数尽管一模一样，但是其变量储存的地址不同所以看做是不同的键，但是如果是浅拷贝储存变量的地址一致就视作是同一个键</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>get (key): 获取某一键值在哈希表中的值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">map.get(1)//2</span><br><span class=\"line\">map.get(2)//undefined 如果找不到就会返回undefined</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>has (key): 判断某个键是否存在，并返回布尔值。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">console.log(map.has(1))//true</span><br><span class=\"line\">console.log(map.has(2))//false</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>clear (): 清除哈希表所有键值对。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">console.log(map.has(1))//true</span><br><span class=\"line\">map.clear()</span><br><span class=\"line\">console.log(map.has(1))//false</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>delete (key): 删除某键。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(1,2)</span><br><span class=\"line\">console.log(map.has(1))//true</span><br><span class=\"line\">map.delete()</span><br><span class=\"line\">console.log(map.has(1))//false</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>keys (): 返回一个包含哈希表所有键的迭代器。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 =[1,2],obj1=&#123;a:1&#125;,arr2 =[1,2],obj2=&#123;a:1&#125;,map = new Map(),fun1 =()=&gt;&#123;&#125;,fun2=()=&gt;&#123;&#125;</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(obj1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">map.set(obj2,1)</span><br><span class=\"line\">map.set(fun1,1)</span><br><span class=\"line\">map.set(fun2,1)</span><br><span class=\"line\">let key = map.keys()</span><br><span class=\"line\">for(let i of key)&#123;</span><br><span class=\"line\">    console.log(i) //[ 1, 2 ] &#123; a: 1 &#125; [ 1, 2 ] &#123; a: 1 &#125; [Function: fun1] [Function: fun2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>values (): 返回一个包含哈希表所有值的迭代器。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 =[1,2],obj1=&#123;a:1&#125;,arr2 =[1,2],obj2=&#123;a:1&#125;,map = new Map(),fun1 =()=&gt;&#123;&#125;,fun2=()=&gt;&#123;&#125;</span><br><span class=\"line\">map.set(arr1,1)</span><br><span class=\"line\">map.set(obj1,1)</span><br><span class=\"line\">map.set(arr2,1)</span><br><span class=\"line\">map.set(obj2,1)</span><br><span class=\"line\">map.set(fun1,1)</span><br><span class=\"line\">map.set(fun2,1)</span><br><span class=\"line\">let val = map.values()</span><br><span class=\"line\">for(let i of val)&#123;</span><br><span class=\"line\">    console.log(i) // 1 1 1 1 1 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n",
            "tags": [
                "学习记录",
                "JavaScript"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/17/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/",
            "url": "https://seele-exzzz.github.io/2023/07/17/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/",
            "title": "链表基础",
            "date_published": "2023-07-17T07:45:02.445Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"链表基础\"><a class=\"markdownIt-Anchor\" href=\"#链表基础\">#</a> 链表基础</h1>\n<h2 id=\"一-链表操作\"><a class=\"markdownIt-Anchor\" href=\"#一-链表操作\">#</a> 一、链表操作</h2>\n<h3 id=\"1力扣上的链表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#1力扣上的链表构造函数\">#</a> 1. 力扣上的链表构造函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意这是力扣上的构造函数不是JavaScript内置函数</span><br><span class=\"line\">function ListNode(val, next) &#123;</span><br><span class=\"line\">    this.val = (val===undefined ? 0 : val)</span><br><span class=\"line\">    this.next = (next===undefined ? null : next)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node = new ListNode(0,head)</span><br><span class=\"line\">//通常用来给链表加上虚拟头结点方便对链表进行操作，第一个形参传值，第二形参传链表</span><br><span class=\"line\">//另外如果用const定义变量再赋予链表，这个变量就无法操作了，原因应该是在操作链表时，链表所储存的变量的地址发生变化。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2链表移动和删除\"><a class=\"markdownIt-Anchor\" href=\"#2链表移动和删除\">#</a> 2. 链表移动和删除</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let cur = head </span><br><span class=\"line\">/*</span><br><span class=\"line\">将head赋给变量cur，如果直接操作head然后再return的话会是null，由于这是浅拷贝，在操作cur时head也会发生改变，所以操作完cur再return head就行。</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">cur = cur.next //让将cur下一位赋给cur就完成了一次移动。</span><br><span class=\"line\"></span><br><span class=\"line\">while(cur)&#123;</span><br><span class=\"line\">\t...\t//对cur操作</span><br><span class=\"line\">\tcur = cur.next</span><br><span class=\"line\">&#125; //这就完成了一次遍历，这时cur是null，head已操作</span><br><span class=\"line\"></span><br><span class=\"line\">cur.netx = cur.next.next //想删除那个节点需找到那个节点的前面一个节点，将前面那个节点的指针指向删除节点后面那个节点。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//力扣上203. 移除链表元素</span><br><span class=\"line\"></span><br><span class=\"line\">//方法一，增加虚拟节点</span><br><span class=\"line\">var removeElements = function(head, val) &#123;</span><br><span class=\"line\">    const cur = new ListNode(0,head)</span><br><span class=\"line\">    let a = cur</span><br><span class=\"line\">    while(a.next)&#123;</span><br><span class=\"line\">        if(a.next.val==val)&#123;</span><br><span class=\"line\">            a.next = a.next.next</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            a = a.next </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cur.next</span><br><span class=\"line\">&#125;;//增加虚拟头节点的好处在于，处理原链表的头节点与其他节点的方式一致，无需在额外考虑头节点如何处理，最后只要return cur.next就行。</span><br><span class=\"line\"></span><br><span class=\"line\">//方法二，在不增加虚拟头节点的情况下删除指定节点</span><br><span class=\"line\">var removeElements = function(head, val) &#123;</span><br><span class=\"line\">    let cur = head</span><br><span class=\"line\">    /*先用while将头节点中值等于val删除，之后就和方法一差不多，需要注意的是，删除后有可能是null或者传来的链表就是null，这是需要if条件判断一下，方法一无需判断是因为加了头节点所以不可能是null*/</span><br><span class=\"line\">    while(cur&amp;&amp;cur.val==val)&#123;</span><br><span class=\"line\">        cur = cur.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(!cur) return cur</span><br><span class=\"line\">    head = cur //将处理好的cur赋值给head，如果不赋值，前面的操作就没有用了。</span><br><span class=\"line\">    while(cur.next)&#123;</span><br><span class=\"line\">        if(cur.next.val==val)&#123;</span><br><span class=\"line\">            cur.next = cur.next.next</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3链表的插入\"><a class=\"markdownIt-Anchor\" href=\"#3链表的插入\">#</a> 3. 链表的插入</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//假设需要往链表head中的第n个节点插入val值，注意链表与数组一样下标从0开始</span><br><span class=\"line\">//首先声明一个变量并将head赋值给这个变量</span><br><span class=\"line\">let cur = head</span><br><span class=\"line\"></span><br><span class=\"line\">方法一：不使用虚拟节点</span><br><span class=\"line\"></span><br><span class=\"line\">//如果不使用虚拟节点的话，得分两种情况，第一种删除头节点，第二种删除后面的节点</span><br><span class=\"line\"></span><br><span class=\"line\">//插入头节点</span><br><span class=\"line\">if(n==0)&#123;</span><br><span class=\"line\">\thead = new ListNode(val,head)</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\t//移动到第n-1个节点前</span><br><span class=\"line\">    while(n&gt;1)&#123; //从n减到1，这时cur到n-1节点前，如果加了虚拟头节点，这时的判断条件为0</span><br><span class=\"line\">\t  cur = cur.next</span><br><span class=\"line\">\t  n --</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   let node = new ListNode(val) </span><br><span class=\"line\">   /*注意这里先把cur.next先赋给node.next，如果反过来先让cur.next变成node.next，再让cur.next赋给node.next，这时cur.next已经是node，相当于自己指向自己。这里有点像两个变量交换。假设有a,b两个变量，交换a,b两个变量的值，不用解构赋值的话</span><br><span class=\"line\">   \t let c = a</span><br><span class=\"line\">   \t a = b</span><br><span class=\"line\">   \t b = c</span><br><span class=\"line\">   */</span><br><span class=\"line\">   node.next = cur.next</span><br><span class=\"line\">   cur.next = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">方法二：使用虚拟头节点</span><br><span class=\"line\">let cur = new ListNode(0,head)</span><br><span class=\"line\">let head = cur</span><br><span class=\"line\">while(n)&#123;</span><br><span class=\"line\">\tcur = cur.next</span><br><span class=\"line\">\tn--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node = new ListNode(val)</span><br><span class=\"line\">node.next = cur.next</span><br><span class=\"line\">cur.next = node</span><br><span class=\"line\">head = head.next //最后注意去除虚拟头节点</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "算法",
                "链表"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/14/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/",
            "url": "https://seele-exzzz.github.io/2023/07/14/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/",
            "title": "二叉树基础",
            "date_published": "2023-07-14T14:04:41.779Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"二叉树基础\"><a class=\"markdownIt-Anchor\" href=\"#二叉树基础\">#</a> 二叉树基础</h1>\n<h2 id=\"一-二叉树种类\"><a class=\"markdownIt-Anchor\" href=\"#一-二叉树种类\">#</a> 一、二叉树种类</h2>\n<h3 id=\"1满二叉树\"><a class=\"markdownIt-Anchor\" href=\"#1满二叉树\">#</a> 1. 满二叉树</h3>\n<p>除最后一层有两个子节点外，最后一层没有子节点，如果某个满二叉树有 k 层则该满二叉树有 2 的 k 次方 - 1 个节点。</p>\n<h3 id=\"2-完全二叉树\"><a class=\"markdownIt-Anchor\" href=\"#2-完全二叉树\">#</a> 2. 完全二叉树</h3>\n<p>最后一层如果有缺的子节点则该子节点为右侧的子节点。如果某个完全二叉树有 k 层，则该完全二叉树则有 2 的 k-1 次方到 2 的 k 次方 - 1 个节点。满二叉树是特殊的完全二叉树</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"\"></p>\n<h3 id=\"3-二叉搜索树\"><a class=\"markdownIt-Anchor\" href=\"#3-二叉搜索树\">#</a> 3. 二叉搜索树</h3>\n<p>二叉搜索树中某个节点的左节点值小于该节点，右节点值大于该节点</p>\n<h3 id=\"4-二叉平衡树\"><a class=\"markdownIt-Anchor\" href=\"#4-二叉平衡树\">#</a> 4. 二叉平衡树</h3>\n<p>在二叉搜索树的条件下，每一个节点的左子树与右子树的高度差不大于一，二叉平衡树是特殊的二叉搜索树。另外二叉树的高度从下往上数，深度从上往下数。</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91.png\" alt=\"\"></p>\n<h2 id=\"二-二叉树的构建\"><a class=\"markdownIt-Anchor\" href=\"#二-二叉树的构建\">#</a> 二、 二叉树的构建</h2>\n<h3 id=\"1-构建力扣上的二叉树\"><a class=\"markdownIt-Anchor\" href=\"#1-构建力扣上的二叉树\">#</a> 1. 构建力扣上的二叉树</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在做力扣上102. 二叉树的层序遍历的时候，好奇试了一下console.dir(root)</span><br><span class=\"line\">TreeNode &#123;</span><br><span class=\"line\">  val: 3,</span><br><span class=\"line\">  left: TreeNode &#123; val: 9, left: null, right: null &#125;,</span><br><span class=\"line\">  right: TreeNode &#123;</span><br><span class=\"line\">    val: 20,</span><br><span class=\"line\">    left: TreeNode &#123; val: 15, left: null, right: null &#125;,</span><br><span class=\"line\">    right: TreeNode &#123; val: 7, left: null, right: null &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;// 结果是这个，根据这个我试着构建了一下二叉树，当然后面看别人的文章发现二叉树远不止这些属性和方法</span><br><span class=\"line\">class TreeNode &#123;</span><br><span class=\"line\">    constructor(val) &#123;</span><br><span class=\"line\">      this.val = val;</span><br><span class=\"line\">      this.left = null;</span><br><span class=\"line\">      this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addleft(left)&#123;</span><br><span class=\"line\">        this.left = left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addright(right)&#123;</span><br><span class=\"line\">        this.right = right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const root = new TreeNode(3)</span><br><span class=\"line\">root.addleft(new TreeNode(9))</span><br><span class=\"line\">root.addright(new TreeNode(20))</span><br><span class=\"line\">root.right.addleft(new TreeNode(15))</span><br><span class=\"line\">root.right.addright(new TreeNode(7))</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-二叉树的遍历\"><a class=\"markdownIt-Anchor\" href=\"#三-二叉树的遍历\">#</a> 三、二叉树的遍历</h2>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/cover/algorithm/binary_tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png\" alt=\"\"></p>\n<h3 id=\"1-深度优先算法\"><a class=\"markdownIt-Anchor\" href=\"#1-深度优先算法\">#</a> 1. 深度优先算法</h3>\n<h4 id=\"1-递归法\"><a class=\"markdownIt-Anchor\" href=\"#1-递归法\">#</a> 1. 递归法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//root为二叉树</span><br><span class=\"line\">const result =[]</span><br><span class=\"line\">const dfs = (root)=&gt;&#123;</span><br><span class=\"line\">    if(root==null) return</span><br><span class=\"line\">    //前序遍历</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    //中序遍历</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    //后序遍历</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dfs(root)</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-迭代法\"><a class=\"markdownIt-Anchor\" href=\"#2-迭代法\">#</a> 2. 迭代法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//前序遍历</span><br><span class=\"line\">const result =[],arr=[root]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let tree = arr.pop()</span><br><span class=\"line\">    if(tree==null) continue</span><br><span class=\"line\">    result.push(tree.val)</span><br><span class=\"line\">\tarr.push(tree.right)</span><br><span class=\"line\">    arr.push(tree.left)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br><span class=\"line\">//后序遍历 在前序遍历的情况下调换调换传入arr的两个子节点，同时将最后的数组反转。</span><br><span class=\"line\">const result =[],arr=[root]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let tree = arr.pop()</span><br><span class=\"line\">    if(tree==null) continue</span><br><span class=\"line\">    result.push(tree.val)</span><br><span class=\"line\">    arr.push(tree.left)</span><br><span class=\"line\">    arr.push(tree.right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result.reverse()</span><br><span class=\"line\">//中序遍历</span><br><span class=\"line\">const result =[],stack=[]</span><br><span class=\"line\">let tree = root</span><br><span class=\"line\">while(stack.length&gt;0||tree)&#123;</span><br><span class=\"line\">\tif(tree)&#123;</span><br><span class=\"line\">\t\tstack.push(tree)</span><br><span class=\"line\">\t\ttree = tree.left</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tlet rootTree = stack.pop()</span><br><span class=\"line\">\t\tresult.push(rootTree.val)</span><br><span class=\"line\">\t\ttree = rootTree.right</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-广度优先搜索span-stylefont-size16px层序遍历span\"><a class=\"markdownIt-Anchor\" href=\"#2-广度优先搜索span-stylefont-size16px层序遍历span\">#</a> 2. 广度优先搜索<span style=\"font-size:16px\">(层序遍历)</span></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//力扣上的层序遍历最后的输出结果似乎都是二维数组，需要将每一层的值用数组储存然后将其储存进一个数组输出出去。</span><br><span class=\"line\">const result = [],arr=[root]</span><br><span class=\"line\">let res=[]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let len = arr.length //相当于快照用于储存当前层数的长度。</span><br><span class=\"line\">    while(len&gt;0)&#123; //当len为零时，说明当前层的值已全部弹出，这时应该用result储存当前层所有数组</span><br><span class=\"line\">        let tree = arr.shift() </span><br><span class=\"line\">        len -- </span><br><span class=\"line\">        if(tree!=null)&#123;</span><br><span class=\"line\">            res.push(tree.val)</span><br><span class=\"line\">            arr.push(tree.left)</span><br><span class=\"line\">            arr.push(tree.right)  </span><br><span class=\"line\">        &#125;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(res.length==0) break </span><br><span class=\"line\">    result.push(res) </span><br><span class=\"line\">    res = [] //清空当前层用于记录下一层的值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "二叉树",
                "算法"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/12/Learning-record/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "url": "https://seele-exzzz.github.io/2023/07/12/Learning-record/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "title": "正则学习记录",
            "date_published": "2023-07-12T05:31:15.886Z",
            "content_html": "<h1 id=\"正则学习记录\"><a class=\"markdownIt-Anchor\" href=\"#正则学习记录\">#</a> 正则学习记录</h1>\n<p>[toc]</p>\n<h2 id=\"一-正则表达式的创建\"><a class=\"markdownIt-Anchor\" href=\"#一-正则表达式的创建\">#</a> 一、正则表达式的创建</h2>\n<h3 id=\"1-字面量创建\"><a class=\"markdownIt-Anchor\" href=\"#1-字面量创建\">#</a> 1. 字面量创建</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = /a/igm //i表示忽略大小写，g表示全局匹配，m表示多行匹配</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-构造函数创建\"><a class=\"markdownIt-Anchor\" href=\"#2-构造函数创建\">#</a> 2. 构造函数创建</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt a = &#x27;a&#x27;</span><br><span class=\"line\">const b = new RegExp(&#x27;a&#x27;) 或者 b = new RegExp(a)//这里的b打印结果与上面字面量创建的a一致</span><br><span class=\"line\">// RegExp有两个参数，第一个参数传入一个字符串表示正则表达式，第二个参数有g全局匹配，i忽略大小写，m多行匹配</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-javascript中正则方法\"><a class=\"markdownIt-Anchor\" href=\"#二-javascript中正则方法\">#</a> 二、JavaScript 中正则方法</h2>\n<h3 id=\"1-test方法\"><a class=\"markdownIt-Anchor\" href=\"#1-test方法\">#</a> 1. test 方法</h3>\n<p>用于测试某一字符串是否满足某一正则表达式，返回一个布尔值。正则表达式的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const str = &#x27;abc&#x27;</span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-exec方法\"><a class=\"markdownIt-Anchor\" href=\"#2-exec方法\">#</a> 2. exec 方法</h3>\n<p>用于匹配某一字符串中满足正则表达式的内容，返回一个数组，第一项为匹配到的内容，第二项 index 为匹配到内容第一个字符所在的索引，input 为匹配的字符串，groups 为命名的捕获组。正则表达式的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const str = &#x27;abcabcaa&#x27;</span><br><span class=\"line\">const result = reg.exec(str)</span><br><span class=\"line\">console.log(result) //[ &#x27;a&#x27;, index: 0, input: &#x27;abcabcaa&#x27;, groups: undefined ]</span><br><span class=\"line\">/*</span><br><span class=\"line\">\t如果正则表达式是全局匹配的话，exec会改变的lastindex，如果exec没匹配上，这时lastindexhi变为0</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reg = /a/g</span><br><span class=\"line\">const str = &#x27;abac&#x27;</span><br><span class=\"line\">for(let i=0;i&lt;3;i++)&#123;</span><br><span class=\"line\">\tconsole.log(reg.lastIndex)</span><br><span class=\"line\">    reg.exec(str)</span><br><span class=\"line\">    console.log(reg.lastIndex)</span><br><span class=\"line\">&#125;// 0,1,1,3,3,0</span><br><span class=\"line\">//可以用?&lt;name&gt;给捕获组命名。这时如果成功匹配返回的对象中groups不再是undefined而是一个属性为捕获组名字，值为匹配到的内容的对象。</span><br><span class=\"line\">const reg = /(?&lt;year&gt;[0-9]+)-(?&lt;month&gt;[0-9]+)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span><br><span class=\"line\">const str = &#x27;2023-07-13&#x27;</span><br><span class=\"line\">const result = reg.exec(str)</span><br><span class=\"line\">console.log(result)</span><br><span class=\"line\">/*</span><br><span class=\"line\">[</span><br><span class=\"line\">  &#x27;2023-07-13&#x27;,</span><br><span class=\"line\">  &#x27;2023&#x27;,</span><br><span class=\"line\">  &#x27;07&#x27;,</span><br><span class=\"line\">  &#x27;13&#x27;,</span><br><span class=\"line\">  index: 0,</span><br><span class=\"line\">  input: &#x27;2023-07-13&#x27;,</span><br><span class=\"line\">  groups: [Object: null prototype] &#123; year: \t &#x27;2023&#x27;, month: &#x27;07&#x27;, day: &#x27;13&#x27; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reg = /(?&lt;year&gt;[0-9]+)-(?&lt;month&gt;[0-9]+)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span><br><span class=\"line\">const str = &#x27;2023-07-13 1145-14-15&#x27;</span><br><span class=\"line\">reg.exec(str).groups</span><br><span class=\"line\">const &#123;year,month,day&#125; = reg.exec(str).groups</span><br><span class=\"line\">console.log(year,month,day) // 1145 14 15</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-match方法\"><a class=\"markdownIt-Anchor\" href=\"#3-match方法\">#</a> 3. match 方法</h3>\n<p>匹配字符串中满足正则表达式的内容并返回一个数组，注意 match 是字符串的方法不是正则表达式的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;abcabcaa&#x27;</span><br><span class=\"line\">const result = str.match(reg) // 如果正则表达式不是全局匹配这时match返回值与exec一致</span><br><span class=\"line\">console.log(result)//[ &#x27;a&#x27;, index: 0, input: &#x27;abcabcaa&#x27;, groups: undefined ]</span><br><span class=\"line\">const resultG = str.match(regG)// 这时会返回一个数组，数组中每一项为满足字符串中满足正则表达式中匹配规则的部分。</span><br><span class=\"line\">console.log(resultG)//[ &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27; ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-search方法\"><a class=\"markdownIt-Anchor\" href=\"#4-search方法\">#</a> 4. search 方法</h3>\n<p>匹配字符串中满足正则表达式的内容并返回第一个匹配到字符的索引。同样这也是字符串方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;babcabcaa&#x27;</span><br><span class=\"line\">const result = str.search(reg) </span><br><span class=\"line\">const resultG = str.search(regG)// 全局匹配一样只返回匹配到第一个满足条件的字符的索引</span><br><span class=\"line\">console.log(result)//1</span><br><span class=\"line\">console.log(resultG)//1</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-replace方法\"><a class=\"markdownIt-Anchor\" href=\"#5-replace方法\">#</a> 5. replace () 方法</h3>\n<p>匹配字符串中满足某字符串或者正则表达式的内容并进行替换，同样也是字符串方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;babcabcaa&#x27;</span><br><span class=\"line\">const result = str.replace(reg,&#x27;*&#x27;) //没有全局匹配只匹配第一个满足条件的</span><br><span class=\"line\">const resultG = str.replace(regG,&#x27;*&#x27;)</span><br><span class=\"line\">console.log(result) //b*bcabcaa</span><br><span class=\"line\">console.log(resultG) //b*bc*bc**</span><br><span class=\"line\">/*</span><br><span class=\"line\">\treplace的第二个参数可以传递一个函数，函数的参数为匹配到的内容，如果正则表达式是全局匹配的话且能匹配到多个字符，则每匹配到一个就会调用一次函数，形参为匹配到的内容</span><br><span class=\"line\">*/</span><br><span class=\"line\">const result = str.replace(reg,(data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data) // a </span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">const resultG = str.replace(regG,(data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data) // a</span><br><span class=\"line\">&#125;) //回调函数调用了3次</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-split方法\"><a class=\"markdownIt-Anchor\" href=\"#6-split方法\">#</a> 6. split 方法</h3>\n<p>用字符串分割数组，分割方式可以为一个正则表达式并返回一个数组，数组每一项为分割后的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &#x27;abc&#x27;</span><br><span class=\"line\">const newstr = str.split(&#x27;&#x27;)</span><br><span class=\"line\">console.log(newstr) //[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span><br><span class=\"line\">/*</span><br><span class=\"line\">\tJavaScript中字符串的方法有限，如果想要反转字符串，简单的办法是用split(&#x27;&#x27;)转化为数\t组然后调用reverse方法反转数组并调用join(&#x27;&#x27;)转回字符串</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reStr = str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) </span><br><span class=\"line\">console.log(reStr) // cba</span><br><span class=\"line\"></span><br><span class=\"line\">const str = &#x27;2023-7-12&#x27; //如果想要这个字符串中的数字</span><br><span class=\"line\">const newstr = str.split(/-/)</span><br><span class=\"line\">console.log(newstr) [ &#x27;2023&#x27;, &#x27;7&#x27;, &#x27;12&#x27; ]</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "学习记录",
                "正则"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/08/Learning-record/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "url": "https://seele-exzzz.github.io/2023/07/08/Learning-record/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "title": "Typescript学习记录",
            "date_published": "2023-07-08T10:22:13.494Z",
            "content_html": "<h1 id=\"typescript学习记录\"><a class=\"markdownIt-Anchor\" href=\"#typescript学习记录\">#</a> Typescript 学习记录</h1>\n<p>[toc]</p>\n<h2 id=\"一-基本类型\"><a class=\"markdownIt-Anchor\" href=\"#一-基本类型\">#</a> 一、基本类型</h2>\n<h3 id=\"1-基本数据类型span-stylefont-size14px-type代表类型span\"><a class=\"markdownIt-Anchor\" href=\"#1-基本数据类型span-stylefont-size14px-type代表类型span\">#</a> 1. 基本数据类型<span style='font-size:14px' >(type 代表类型)</span></h3>\n<ul>\n<li>any: 任意类型</li>\n<li>string: 字符串类型</li>\n<li>boolean: 布尔类型</li>\n<li>type[]，Array<type>: 数组类型两种表示方法</li>\n<li>[type] : 元组，如果要储存类似经纬度这类需要两个数字的数据则可以用 [number,number]</li>\n<li>void : 表示函数无返回值</li>\n<li>null : null 类型</li>\n<li>undefined : undefined 类型</li>\n<li>never : 表示从来不会出现的值</li>\n</ul>\n<h3 id=\"2-函数形参和返回值的类型\"><a class=\"markdownIt-Anchor\" href=\"#2-函数形参和返回值的类型\">#</a> 2. 函数形参和返回值的类型</h3>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>):<span class=\"function\"><span class=\"params\">string</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;<span class=\"comment\">//void 表示无返回值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-类型推断\"><a class=\"markdownIt-Anchor\" href=\"#3-类型推断\">#</a> 3. 类型推断</h3>\n<p>ide 在编译文件时会对变量的类型进行判断，所以在声明一个变量后立马赋值，声明一个对象并对其中的属性赋值又或者函数的返回值与形参有关可以推断出来等等，这些可以推断出来的就无需加上类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span> <span class=\"comment\">//ide会推断这个变量a的类型为number类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a : <span class=\"number\">1</span> <span class=\"comment\">//同样ide会推断这个a属性为number类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b <span class=\"comment\">//ide会推断这里的返回值为string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-关键字type和联合类型\"><a class=\"markdownIt-Anchor\" href=\"#4-关键字type和联合类型\">#</a> 4. 关键字 type 和联合类型</h3>\n<p>利用 type 给类型取一个别名，type 可以与联合类型一起使用</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> str1 = <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>:str1</span><br><span class=\"line\"><span class=\"keyword\">type</span> t = <span class=\"built_in\">number</span> | str1</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>:t</span><br><span class=\"line\"><span class=\"keyword\">type</span> funType = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">fun</span> = (<span class=\"params\">a:funType</span>)=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-接口\"><a class=\"markdownIt-Anchor\" href=\"#二-接口\">#</a> 二、接口</h2>\n<p>如果一个对象会重复使用，则可以使用将其抽出写成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//接口与对象不同，属性之间可不加逗号</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">b</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-接口属性\"><a class=\"markdownIt-Anchor\" href=\"#1-接口属性\">#</a> 1. 接口属性</h3>\n<ul>\n<li>可选属性：如果函数的形参对象中的某些属性是可选的。比如在使用 axios 时，传入的配置对象中 method 属性是可选属性如果不传默认是 get。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    a?:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//a是可选属性，可不传。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">b</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(&#123;a=<span class=\"number\">1</span>,b&#125;:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125; <span class=\"comment\">//如果想给a一个默认值，如果没传就使用默认值的话</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>只读属性：如果接口中的某些属性不可修改，只读的话则可以使用只读属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">readonly</span> <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">   <span class=\"keyword\">readonly</span> <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(&#123;a,b&#125;:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引类型：索引签名允许我们定义一个可以包含不同属性名称的动态对象并且固定属性的类型必须与索引类型相同或是其子级。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">    [<span class=\"attr\">propName</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">abc</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "学习记录",
                "typescript"
            ]
        }
    ]
}