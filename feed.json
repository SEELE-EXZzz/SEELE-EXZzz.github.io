{
    "version": "https://jsonfeed.org/version/1",
    "title": "个人博客",
    "subtitle": "",
    "icon": "https://seele-exzzz.github.io/assets/favicon.ico",
    "description": "",
    "home_page_url": "https://seele-exzzz.github.io",
    "items": [
        {
            "id": "https://seele-exzzz.github.io/2023/07/17/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/",
            "url": "https://seele-exzzz.github.io/2023/07/17/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/",
            "title": "链表基础",
            "date_published": "2023-07-17T07:45:02.445Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"链表基础\"><a class=\"markdownIt-Anchor\" href=\"#链表基础\">#</a> 链表基础</h1>\n<h2 id=\"一-链表操作\"><a class=\"markdownIt-Anchor\" href=\"#一-链表操作\">#</a> 一、链表操作</h2>\n<h3 id=\"1力扣上的链表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#1力扣上的链表构造函数\">#</a> 1. 力扣上的链表构造函数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意这是力扣上的构造函数不是JavaScript内置函数</span><br><span class=\"line\">function ListNode(val, next) &#123;</span><br><span class=\"line\">    this.val = (val===undefined ? 0 : val)</span><br><span class=\"line\">    this.next = (next===undefined ? null : next)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node = new ListNode(0,head)</span><br><span class=\"line\">//通常用来给链表加上虚拟头结点方便对链表进行操作，第一个形参传值，第二形参传链表</span><br><span class=\"line\">//另外如果用const定义变量再赋予链表，这个变量就无法操作了，原因应该是在操作链表时，链表所储存的变量的地址发生变化。</span><br></pre></td></tr></table></figure>\n<h3 id=\"2链表移动和删除\"><a class=\"markdownIt-Anchor\" href=\"#2链表移动和删除\">#</a> 2. 链表移动和删除</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let cur = head /*将head赋给变量cur，如果直接操作head然后再return的话会是null，由于这是浅拷贝，在操作cur时head也会发生改变，所以操作完cur再return head就行。*/</span><br><span class=\"line\"></span><br><span class=\"line\">cur = cur.next //让将cur下一位赋给cur就完成了一次移动。</span><br><span class=\"line\"></span><br><span class=\"line\">while(cur)&#123;</span><br><span class=\"line\">\t...\t//对cur操作</span><br><span class=\"line\">\tcur = cur.next</span><br><span class=\"line\">&#125; //这就完成了一次遍历，这时cur是null，head已操作</span><br><span class=\"line\"></span><br><span class=\"line\">cur.netx = cur.next.next //想删除那个节点需找到那个节点的前面一个节点，将前面那个节点的指针指向删除节点后面那个节点。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//力扣上203. 移除链表元素</span><br><span class=\"line\"></span><br><span class=\"line\">//方法一，增加虚拟节点</span><br><span class=\"line\">var removeElements = function(head, val) &#123;</span><br><span class=\"line\">    const cur = new ListNode(0,head)</span><br><span class=\"line\">    let a = cur</span><br><span class=\"line\">    while(a.next)&#123;</span><br><span class=\"line\">        if(a.next.val==val)&#123;</span><br><span class=\"line\">            a.next = a.next.next</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            a = a.next </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return cur.next</span><br><span class=\"line\">&#125;;//增加虚拟头节点的好处在于，处理原链表的头节点与其他节点的方式一致，无需在额外考虑头节点如何处理，最后只要return cur.next就行。</span><br><span class=\"line\"></span><br><span class=\"line\">//方法二，在不增加虚拟头节点的情况下删除指定节点</span><br><span class=\"line\">var removeElements = function(head, val) &#123;</span><br><span class=\"line\">    let cur = head</span><br><span class=\"line\">    /*先用while将头节点中值等于val删除，之后就和方法一差不多，需要注意的是，删除后有可能是null或者传来的链表就是null，这是需要if条件判断一下，方法一无需判断是因为加了头节点所以不可能是null*/</span><br><span class=\"line\">    while(cur&amp;&amp;cur.val==val)&#123;</span><br><span class=\"line\">        cur = cur.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(!cur) return cur</span><br><span class=\"line\">    head = cur //将处理好的cur赋值给head，如果不赋值，前面的操作就没有用了。</span><br><span class=\"line\">    while(cur.next)&#123;</span><br><span class=\"line\">        if(cur.next.val==val)&#123;</span><br><span class=\"line\">            cur.next = cur.next.next</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3链表的插入\"><a class=\"markdownIt-Anchor\" href=\"#3链表的插入\">#</a> 3. 链表的插入</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//假设需要往链表head中的第n个节点插入val值，注意链表与数组一样下标从0开始</span><br><span class=\"line\">//首先声明一个变量并将head赋值给这个变量</span><br><span class=\"line\">let cur = head</span><br><span class=\"line\"></span><br><span class=\"line\">方法一：不使用虚拟节点</span><br><span class=\"line\"></span><br><span class=\"line\">//如果不使用虚拟节点的话，得分两种情况，第一种删除头节点，第二种删除后面的节点</span><br><span class=\"line\"></span><br><span class=\"line\">//插入头节点</span><br><span class=\"line\">if(n==0)&#123;</span><br><span class=\"line\">\thead = new ListNode(val,head)</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\t//移动到第n-1个节点前</span><br><span class=\"line\">    while(n&gt;1)&#123; //从n减到1，这时cur到n-1节点前，如果加了虚拟头节点，这时的判断条件为0</span><br><span class=\"line\">\t  cur = cur.next</span><br><span class=\"line\">\t  n --</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   let node = new ListNode(val) </span><br><span class=\"line\">   /*注意这里先把cur.next先赋给node.next，如果反过来先让cur.next变成node.next，再让cur.next赋给node.next，这时cur.next已经是node，相当于自己指向自己。这里有点像两个变量交换。假设有a,b两个变量，交换a,b两个变量的值，不用解构赋值的话</span><br><span class=\"line\">   \t let c = a</span><br><span class=\"line\">   \t a = b</span><br><span class=\"line\">   \t b = c</span><br><span class=\"line\">   */</span><br><span class=\"line\">   node.next = cur.next</span><br><span class=\"line\">   cur.next = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">方法二：使用虚拟头节点</span><br><span class=\"line\">let cur = new ListNode(0,head)</span><br><span class=\"line\">let head = cur</span><br><span class=\"line\">while(n)&#123;</span><br><span class=\"line\">\tcur = cur.next</span><br><span class=\"line\">\tn--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let node = new ListNode(val)</span><br><span class=\"line\">node.next = cur.next</span><br><span class=\"line\">cur.next = node</span><br><span class=\"line\">head = head.next //最后注意去除虚拟头节点</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-链表进阶\"><a class=\"markdownIt-Anchor\" href=\"#二-链表进阶\">#</a> 二、链表进阶</h2>\n<h3 id=\"1-链表反转\"><a class=\"markdownIt-Anchor\" href=\"#1-链表反转\">#</a> 1. 链表反转</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//206. 反转链表</span><br><span class=\"line\"></span><br><span class=\"line\">//方法一，双指针法</span><br><span class=\"line\"></span><br><span class=\"line\">var reverseList = function(head) &#123;</span><br><span class=\"line\">    let cur = head,pre = null</span><br><span class=\"line\">    while(cur)&#123;</span><br><span class=\"line\">        let temp = cur.next</span><br><span class=\"line\">        cur.next = pre</span><br><span class=\"line\">        pre = cur</span><br><span class=\"line\">        cur = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return pre</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "算法",
                "链表"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/14/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/",
            "url": "https://seele-exzzz.github.io/2023/07/14/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/",
            "title": "二叉树基础",
            "date_published": "2023-07-14T14:04:41.779Z",
            "content_html": "<p>[toc]</p>\n<h1 id=\"二叉树基础\"><a class=\"markdownIt-Anchor\" href=\"#二叉树基础\">#</a> 二叉树基础</h1>\n<h2 id=\"一-二叉树种类\"><a class=\"markdownIt-Anchor\" href=\"#一-二叉树种类\">#</a> 一、二叉树种类</h2>\n<h3 id=\"1满二叉树\"><a class=\"markdownIt-Anchor\" href=\"#1满二叉树\">#</a> 1. 满二叉树</h3>\n<p>除最后一层有两个子节点外，最后一层没有子节点，如果某个满二叉树有 k 层则该满二叉树有 2 的 k 次方 - 1 个节点。</p>\n<h3 id=\"2-完全二叉树\"><a class=\"markdownIt-Anchor\" href=\"#2-完全二叉树\">#</a> 2. 完全二叉树</h3>\n<p>最后一层如果有缺的子节点则该子节点为右侧的子节点。如果某个完全二叉树有 k 层，则该完全二叉树则有 2 的 k-1 次方到 2 的 k 次方 - 1 个节点。满二叉树是特殊的完全二叉树</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"\"></p>\n<h3 id=\"3-二叉搜索树\"><a class=\"markdownIt-Anchor\" href=\"#3-二叉搜索树\">#</a> 3. 二叉搜索树</h3>\n<p>二叉搜索树中某个节点的左节点值小于该节点，右节点值大于该节点</p>\n<h3 id=\"4-二叉平衡树\"><a class=\"markdownIt-Anchor\" href=\"#4-二叉平衡树\">#</a> 4. 二叉平衡树</h3>\n<p>在二叉搜索树的条件下，高度差不大于一，二叉平衡树是特殊的二叉搜索树。</p>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%92%8C%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91.png\" alt=\"\"></p>\n<h2 id=\"二-二叉树的构建\"><a class=\"markdownIt-Anchor\" href=\"#二-二叉树的构建\">#</a> 二、 二叉树的构建</h2>\n<h3 id=\"1-构建力扣上的二叉树\"><a class=\"markdownIt-Anchor\" href=\"#1-构建力扣上的二叉树\">#</a> 1. 构建力扣上的二叉树</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在做力扣上102. 二叉树的层序遍历的时候，好奇试了一下console.dir(root)</span><br><span class=\"line\">TreeNode &#123;</span><br><span class=\"line\">  val: 3,</span><br><span class=\"line\">  left: TreeNode &#123; val: 9, left: null, right: null &#125;,</span><br><span class=\"line\">  right: TreeNode &#123;</span><br><span class=\"line\">    val: 20,</span><br><span class=\"line\">    left: TreeNode &#123; val: 15, left: null, right: null &#125;,</span><br><span class=\"line\">    right: TreeNode &#123; val: 7, left: null, right: null &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;// 结果是这个，根据这个我试着构建了一下二叉树，当然后面看别人的文章发现二叉树远不止这些属性和方法</span><br><span class=\"line\">class TreeNode &#123;</span><br><span class=\"line\">    constructor(val) &#123;</span><br><span class=\"line\">      this.val = val;</span><br><span class=\"line\">      this.left = null;</span><br><span class=\"line\">      this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addleft(left)&#123;</span><br><span class=\"line\">        this.left = left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addright(right)&#123;</span><br><span class=\"line\">        this.right = right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const root = new TreeNode(3)</span><br><span class=\"line\">root.addleft(new TreeNode(9))</span><br><span class=\"line\">root.addright(new TreeNode(20))</span><br><span class=\"line\">root.right.addleft(new TreeNode(15))</span><br><span class=\"line\">root.right.addright(new TreeNode(7))</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-二叉树的遍历\"><a class=\"markdownIt-Anchor\" href=\"#三-二叉树的遍历\">#</a> 三、二叉树的遍历</h2>\n<p><img data-src=\"https://typora-seele-exzzz.oss-cn-guangzhou.aliyuncs.com/img/algorithm/binary_tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png\" alt=\"\"></p>\n<h3 id=\"1-深度优先算法\"><a class=\"markdownIt-Anchor\" href=\"#1-深度优先算法\">#</a> 1. 深度优先算法</h3>\n<h4 id=\"1-递归法\"><a class=\"markdownIt-Anchor\" href=\"#1-递归法\">#</a> 1. 递归法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//root为二叉树</span><br><span class=\"line\">const result =[]</span><br><span class=\"line\">const dfs = (root)=&gt;&#123;</span><br><span class=\"line\">    if(root==null) return</span><br><span class=\"line\">    //前序遍历</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    //中序遍历</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    //后序遍历</span><br><span class=\"line\">    dfs(root.left)</span><br><span class=\"line\">    dfs(root.right)</span><br><span class=\"line\">    result.push(root.val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dfs(root)</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-迭代法\"><a class=\"markdownIt-Anchor\" href=\"#2-迭代法\">#</a> 2. 迭代法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//前序遍历</span><br><span class=\"line\">const result =[],arr=[root]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let tree = arr.pop()</span><br><span class=\"line\">    if(tree==null) continue</span><br><span class=\"line\">    result.push(tree.val)</span><br><span class=\"line\">\tarr.push(tree.right)</span><br><span class=\"line\">    arr.push(tree.left)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br><span class=\"line\">//后序遍历 在前序遍历的情况下调换调换传入arr的两个子节点，同时将最后的数组反转。</span><br><span class=\"line\">const result =[],arr=[root]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let tree = arr.pop()</span><br><span class=\"line\">    if(tree==null) continue</span><br><span class=\"line\">    result.push(tree.val)</span><br><span class=\"line\">    arr.push(tree.left)</span><br><span class=\"line\">    arr.push(tree.right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result.reverse()</span><br><span class=\"line\">//中序遍历</span><br><span class=\"line\">const result =[],stack=[]</span><br><span class=\"line\">let tree = root</span><br><span class=\"line\">while(stack.length&gt;0||tree)&#123;</span><br><span class=\"line\">\tif(tree)&#123;</span><br><span class=\"line\">\t\tstack.push(tree)</span><br><span class=\"line\">\t\ttree = tree.left</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tlet rootTree = stack.pop()</span><br><span class=\"line\">\t\tresult.push(rootTree.val)</span><br><span class=\"line\">\t\ttree = rootTree.right</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-广度优先搜索span-stylefont-size16px层序遍历span\"><a class=\"markdownIt-Anchor\" href=\"#2-广度优先搜索span-stylefont-size16px层序遍历span\">#</a> 2. 广度优先搜索<span style=\"font-size:16px\">(层序遍历)</span></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//力扣上的层序遍历最后的输出结果似乎都是二维数组，需要将每一层的值用数组储存然后将其储存进一个数组输出出去。</span><br><span class=\"line\">const result = [],arr=[root]</span><br><span class=\"line\">let res=[]</span><br><span class=\"line\">while(arr.length&gt;0)&#123;</span><br><span class=\"line\">    let len = arr.length //相当于快照用于储存当前层数的长度。</span><br><span class=\"line\">    while(len&gt;0)&#123; //当len为零时，说明当前层的值已全部弹出，这时应该用result储存当前层所有数组</span><br><span class=\"line\">        let tree = arr.shift() </span><br><span class=\"line\">        len -- </span><br><span class=\"line\">        if(tree!=null)&#123;</span><br><span class=\"line\">            res.push(tree.val)</span><br><span class=\"line\">            arr.push(tree.left)</span><br><span class=\"line\">            arr.push(tree.right)  </span><br><span class=\"line\">        &#125;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(res.length==0) break </span><br><span class=\"line\">    result.push(res) </span><br><span class=\"line\">    res = [] //清空当前层用于记录下一层的值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return result</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法",
                "二叉树",
                "算法"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/12/Learning-record/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "url": "https://seele-exzzz.github.io/2023/07/12/Learning-record/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "title": "正则学习记录",
            "date_published": "2023-07-12T05:31:15.886Z",
            "content_html": "<h1 id=\"正则学习记录\"><a class=\"markdownIt-Anchor\" href=\"#正则学习记录\">#</a> 正则学习记录</h1>\n<p>[toc]</p>\n<h2 id=\"一-正则表达式的创建\"><a class=\"markdownIt-Anchor\" href=\"#一-正则表达式的创建\">#</a> 一、正则表达式的创建</h2>\n<h3 id=\"1-字面量创建\"><a class=\"markdownIt-Anchor\" href=\"#1-字面量创建\">#</a> 1. 字面量创建</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = /a/igm //i表示忽略大小写，g表示全局匹配，m表示多行匹配</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-构造函数创建\"><a class=\"markdownIt-Anchor\" href=\"#2-构造函数创建\">#</a> 2. 构造函数创建</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt a = &#x27;a&#x27;</span><br><span class=\"line\">const b = new RegExp(&#x27;a&#x27;) 或者 b = new RegExp(a)//这里的b打印结果与上面字面量创建的a一致</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-javascript中正则方法\"><a class=\"markdownIt-Anchor\" href=\"#二-javascript中正则方法\">#</a> 二、JavaScript 中正则方法</h2>\n<h3 id=\"1-test方法\"><a class=\"markdownIt-Anchor\" href=\"#1-test方法\">#</a> 1. test 方法</h3>\n<p>用于测试某一字符串是否满足某一正则表达式，返回一个布尔值。正则表达式的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const str = &#x27;abc&#x27;</span><br><span class=\"line\">reg.test(str)</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-exec方法\"><a class=\"markdownIt-Anchor\" href=\"#2-exec方法\">#</a> 2. exec 方法</h3>\n<p>用于匹配某一字符串中满足正则表达式的内容，返回一个数组，第一项为匹配到的内容，第二项 index 为匹配到内容第一个字符所在的索引，input 为匹配的字符串，groups 为命名的捕获组。正则表达式的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const str = &#x27;abcabcaa&#x27;</span><br><span class=\"line\">const result = reg.exec(str)</span><br><span class=\"line\">console.log(result) //[ &#x27;a&#x27;, index: 0, input: &#x27;abcabcaa&#x27;, groups: undefined ]</span><br><span class=\"line\">/*</span><br><span class=\"line\">\t如果正则表达式是全局匹配的话，exec会改变的lastindex，如果exec没匹配上，这时lastindexhi变为0</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reg = /a/g</span><br><span class=\"line\">const str = &#x27;abac&#x27;</span><br><span class=\"line\">for(let i=0;i&lt;3;i++)&#123;</span><br><span class=\"line\">\tconsole.log(reg.lastIndex)</span><br><span class=\"line\">    reg.exec(str)</span><br><span class=\"line\">    console.log(reg.lastIndex)</span><br><span class=\"line\">&#125;// 0,1,1,3,3,0</span><br><span class=\"line\">//可以用?&lt;name&gt;给捕获组命名。这时如果成功匹配返回的对象中groups不再是undefined而是一个属性为捕获组名字，值为匹配到的内容的对象。</span><br><span class=\"line\">const reg = /(?&lt;year&gt;[0-9]+)-(?&lt;month&gt;[0-9]+)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span><br><span class=\"line\">const str = &#x27;2023-07-13&#x27;</span><br><span class=\"line\">const result = reg.exec(str)</span><br><span class=\"line\">console.log(result)</span><br><span class=\"line\">/*</span><br><span class=\"line\">[</span><br><span class=\"line\">  &#x27;2023-07-13&#x27;,</span><br><span class=\"line\">  &#x27;2023&#x27;,</span><br><span class=\"line\">  &#x27;07&#x27;,</span><br><span class=\"line\">  &#x27;13&#x27;,</span><br><span class=\"line\">  index: 0,</span><br><span class=\"line\">  input: &#x27;2023-07-13&#x27;,</span><br><span class=\"line\">  groups: [Object: null prototype] &#123; year: \t &#x27;2023&#x27;, month: &#x27;07&#x27;, day: &#x27;13&#x27; &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reg = /(?&lt;year&gt;[0-9]+)-(?&lt;month&gt;[0-9]+)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span><br><span class=\"line\">const str = &#x27;2023-07-13 1145-14-15&#x27;</span><br><span class=\"line\">reg.exec(str).groups</span><br><span class=\"line\">const &#123;year,month,day&#125; = reg.exec(str).groups</span><br><span class=\"line\">console.log(year,month,day) // 1145 14 15</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-match方法\"><a class=\"markdownIt-Anchor\" href=\"#3-match方法\">#</a> 3. match 方法</h3>\n<p>匹配字符串中满足正则表达式的内容并返回一个数组，注意 match 是字符串的方法不是正则表达式的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;abcabcaa&#x27;</span><br><span class=\"line\">const result = str.match(reg) // 如果正则表达式不是全局匹配这时match返回值与exec一致</span><br><span class=\"line\">console.log(result)//[ &#x27;a&#x27;, index: 0, input: &#x27;abcabcaa&#x27;, groups: undefined ]</span><br><span class=\"line\">const resultG = str.match(regG)// 这时会返回一个数组，数组中每一项为满足字符串中满足正则表达式中匹配规则的部分。</span><br><span class=\"line\">console.log(resultG)//[ &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27; ]</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-search方法\"><a class=\"markdownIt-Anchor\" href=\"#4-search方法\">#</a> 4. search 方法</h3>\n<p>匹配字符串中满足正则表达式的内容并返回第一个匹配到字符的索引。同样这也是字符串方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;babcabcaa&#x27;</span><br><span class=\"line\">const result = str.search(reg) </span><br><span class=\"line\">const resultG = str.search(regG)// 全局匹配一样只返回匹配到第一个满足条件的字符的索引</span><br><span class=\"line\">console.log(result)//1</span><br><span class=\"line\">console.log(resultG)//1</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-replace方法\"><a class=\"markdownIt-Anchor\" href=\"#5-replace方法\">#</a> 5. replace () 方法</h3>\n<p>匹配字符串中满足某字符串或者正则表达式的内容并进行替换，同样也是字符串方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reg = /a/</span><br><span class=\"line\">const regG = /a/g</span><br><span class=\"line\">const str = &#x27;babcabcaa&#x27;</span><br><span class=\"line\">const result = str.replace(reg,&#x27;*&#x27;) //没有全局匹配只匹配第一个满足条件的</span><br><span class=\"line\">const resultG = str.replace(regG,&#x27;*&#x27;)</span><br><span class=\"line\">console.log(result) //b*bcabcaa</span><br><span class=\"line\">console.log(resultG) //b*bc*bc**</span><br><span class=\"line\">/*</span><br><span class=\"line\">\treplace的第二个参数可以传递一个函数，函数的参数为匹配到的内容，如果正则表达式是全局匹配的话且能匹配到多个字符，则每匹配到一个就会调用一次函数，形参为匹配到的内容</span><br><span class=\"line\">*/</span><br><span class=\"line\">const result = str.replace(reg,(data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data) // a </span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">const resultG = str.replace(regG,(data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data) // a</span><br><span class=\"line\">&#125;) //回调函数调用了3次</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-split方法\"><a class=\"markdownIt-Anchor\" href=\"#6-split方法\">#</a> 6. split 方法</h3>\n<p>用字符串分割数组，分割方式可以为一个正则表达式并返回一个数组，数组每一项为分割后的字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &#x27;abc&#x27;</span><br><span class=\"line\">const newstr = str.split(&#x27;&#x27;)</span><br><span class=\"line\">console.log(newstr) //[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span><br><span class=\"line\">/*</span><br><span class=\"line\">\tJavaScript中字符串的方法有限，如果想要反转字符串，简单的办法是用split(&#x27;&#x27;)转化为数\t组然后调用reverse方法反转数组并调用join(&#x27;&#x27;)转回字符串</span><br><span class=\"line\">*/</span><br><span class=\"line\">const reStr = str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) </span><br><span class=\"line\">console.log(reStr) // cba</span><br><span class=\"line\"></span><br><span class=\"line\">const str = &#x27;2023-7-12&#x27; //如果想要这个字符串中的数字</span><br><span class=\"line\">const newstr = str.split(/-/)</span><br><span class=\"line\">console.log(newstr) [ &#x27;2023&#x27;, &#x27;7&#x27;, &#x27;12&#x27; ]</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "学习记录",
                "正则"
            ]
        },
        {
            "id": "https://seele-exzzz.github.io/2023/07/08/Learning-record/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "url": "https://seele-exzzz.github.io/2023/07/08/Learning-record/Typescript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
            "title": "Typescript学习记录",
            "date_published": "2023-07-08T10:22:13.494Z",
            "content_html": "<h1 id=\"typescript学习记录\"><a class=\"markdownIt-Anchor\" href=\"#typescript学习记录\">#</a> Typescript 学习记录</h1>\n<p>[toc]</p>\n<h2 id=\"一-基本类型\"><a class=\"markdownIt-Anchor\" href=\"#一-基本类型\">#</a> 一、基本类型</h2>\n<h3 id=\"1-基本数据类型span-stylefont-size14px-type代表类型span\"><a class=\"markdownIt-Anchor\" href=\"#1-基本数据类型span-stylefont-size14px-type代表类型span\">#</a> 1. 基本数据类型<span style='font-size:14px' >(type 代表类型)</span></h3>\n<ul>\n<li>any: 任意类型</li>\n<li>string: 字符串类型</li>\n<li>boolean: 布尔类型</li>\n<li>type[]，Array<type>: 数组类型两种表示方法</li>\n<li>[type] : 元组，如果要储存类似经纬度这类需要两个数字的数据则可以用 [number,number]</li>\n<li>void : 表示函数无返回值</li>\n<li>null : null 类型</li>\n<li>undefined : undefined 类型</li>\n<li>never : 表示从来不会出现的值</li>\n</ul>\n<h3 id=\"2-函数形参和返回值的类型\"><a class=\"markdownIt-Anchor\" href=\"#2-函数形参和返回值的类型\">#</a> 2. 函数形参和返回值的类型</h3>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>):<span class=\"function\"><span class=\"params\">string</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;<span class=\"comment\">//void 表示无返回值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-类型推断\"><a class=\"markdownIt-Anchor\" href=\"#3-类型推断\">#</a> 3. 类型推断</h3>\n<p>ide 在编译文件时会对变量的类型进行判断，所以在声明一个变量后立马赋值，声明一个对象并对其中的属性赋值又或者函数的返回值与形参有关可以推断出来等等，这些可以推断出来的就无需加上类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span> <span class=\"comment\">//ide会推断这个变量a的类型为number类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a : <span class=\"number\">1</span> <span class=\"comment\">//同样ide会推断这个a属性为number类型</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun = (<span class=\"attr\">a</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">b</span>:<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b <span class=\"comment\">//ide会推断这里的返回值为string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-关键字type和联合类型\"><a class=\"markdownIt-Anchor\" href=\"#4-关键字type和联合类型\">#</a> 4. 关键字 type 和联合类型</h3>\n<p>利用 type 给类型取一个别名，type 可以与联合类型一起使用</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> str1 = <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>:str1</span><br><span class=\"line\"><span class=\"keyword\">type</span> t = <span class=\"built_in\">number</span> | str1</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>:t</span><br><span class=\"line\"><span class=\"keyword\">type</span> funType = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">fun</span> = (<span class=\"params\">a:funType</span>)=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-接口\"><a class=\"markdownIt-Anchor\" href=\"#二-接口\">#</a> 二、接口</h2>\n<p>如果一个对象会重复使用，则可以使用将其抽出写成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//接口与对象不同，属性之间可不加逗号</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">b</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-接口属性\"><a class=\"markdownIt-Anchor\" href=\"#1-接口属性\">#</a> 1. 接口属性</h3>\n<ul>\n<li>可选属性：如果函数的形参对象中的某些属性是可选的。比如在使用 axios 时，传入的配置对象中 method 属性是可选属性如果不传默认是 get。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    a?:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125; <span class=\"comment\">//a是可选属性，可不传。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">b</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(&#123;a=<span class=\"number\">1</span>,b&#125;:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125; <span class=\"comment\">//如果想给a一个默认值，如果没传就使用默认值的话</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>只读属性：如果接口中的某些属性不可修改，只读的话则可以使用只读属性</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">readonly</span> <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">   <span class=\"keyword\">readonly</span> <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(&#123;a,b&#125;:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>索引类型：索引签名允许我们定义一个可以包含不同属性名称的动态对象并且固定属性的类型必须与索引类型相同或是其子级。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iobj</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>:<span class=\"built_in\">number</span></span><br><span class=\"line\">    <span class=\"attr\">b</span>:<span class=\"built_in\">string</span></span><br><span class=\"line\">    [<span class=\"attr\">propName</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fun=(<span class=\"attr\">abc</span>:<span class=\"title class_\">Iobj</span>):<span class=\"function\"><span class=\"params\">void</span>=&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "学习记录",
                "typescript"
            ]
        }
    ]
}